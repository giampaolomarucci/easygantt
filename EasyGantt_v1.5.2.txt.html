<!DOCTYPE html>

<!-- Title: Easy Gantt 
     Author: Giampaolo Marucci
     Version: 1.5.2
     Date: 28 February 2025 -->

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    #ganttChart {
      border: 1px solid #ccc;
    }
    #title {
      text-align: center;
      font-size: 14px;
      font-weight: bold;
      margin-top: 5px;
    }
    #inputArea {
      margin: 10px;
      display: flex; 
      align-items: flex-start;
      font-size: 12px;
    }
    #inputArea textarea {
      font-size: 12px; 
    }
    #inputArea button {
      font-size: 10px;
    }
    #inputArea input[type="date"] {
      width: 95px;
      height: 12px;
      font-size: 11px; 
    }
    #inputArea input[type="checkbox"] {
      width: auto; /* Prevents checkbox from being too wide */
    }

    /* Styling for the tab buttons */
    .tab-container {
        display: flex;
        flex-direction: column;
    }
    .tab {
        display: flex;
        cursor: pointer;
    }
    .tab div {
        padding: 5px 10px;
        border: 0px solid #ccc;
        margin-right: 10px;
        background-color: #f1f1f1;
    }
    .tab div.active {
        background-color: #ddd;
        border: 1px solid #ccc;
    }

    /* Styling for tab content */
    .tab-content-container {
        margin-top: 2px;
    }
    .tab-content {
        display: none;
        padding: 10px;
        border: 1px solid #ccc;
    }
    .tab-content.active {
        display: block;
    }
    
    #options {
      flex-direction: column;
    }
    #options label {
      margin-left: 16px;
      font-size: 12px;
    }
    #options input[type="number"]{
      width: 40px;
      font-size: 10px; 
      padding: 1px;
    }
    #options select,
    #options input[type="checkbox"], 
    #options input[type="date"] {
      width: 70px;
      font-size: 10px; 
      padding: 1px;
    }
    #options input[type="checkbox"] {
      width: auto; /* Prevents checkbox from being too wide */
    }

    /* Styles for the Non-Working Dates popup */
    .popup-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    .popup-container {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        width: 400px;
        max-width: 90%;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .date-range-row {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }
    .date-range-row input {
        flex-grow: 1;
        margin-right: 10px;
    }
    .popup-controls {
        display: flex;
        justify-content: space-between;
        margin-top: 20px;
    }
    .checkbox-section {
        margin-bottom: 15px;
    }
    
  </style>
</head>

<body onload="generateGanttChart()">

<div id="title">Easy Gantt - by Giampaolo Marucci</div>

<div id="inputArea">
  <div>
    <label for="csvInput" title="Input field for tasks data"><b>Comma separated or tab separated values for:</b></label><br>
    <label for="csvInput" title="Input field for tasks data"><i>Task Id, Task name, Duration, Percent complete, Predecessors</i></label>   
    <br>
    <textarea id="csvInput" rows="4" cols="44" onchange="generateGanttChart()">
1,Task 1.1,5 days,100.00%,
2,Task 1.2,8 days,70.00%,1FS-1 day
3,Task 1.3,4 days,0.00%,2FF+1 day
4,Milestone 1,0 days,0.00%,3;2;1
5,Task 2.1,3 days,60.00%,1SS
6,Task 2.2,7 days,30.00%,5
7,Task 2.3,6 days,0.00%,6FS+3 days
8,Task 2.4,12 days,0.00%,5;6
9,Milestone 2,0 days,0.00%,5;6;7;8
10,Milestone 3,0 days,0.00%,9;4
    </textarea><br>

    <!--<button id="viewGanttChart" onclick="generateGanttChart()">View Gantt Chart</button>-->
    <button id="openProjectFromFile" title="Open a Gantt chart and its Settings from a JSON file type" onclick="openProjectFromFile()">Open JSON</button>
    <button id="saveProjectToFile" title="Save the Gantt chart and Settings in a JSON file type" onclick="saveProjectToFile()">Save as JSON</button>
    <button id="exportSVGButton" title="Save the Gantt chart as SVG - Scalable Vector Graphics - file" onclick="exportGanttChartAsSVG()">Save as SVG</button>
    <button id="saveAsCSV" title="Save the tasks in a CSV file type" 
           onclick='saveTasksAsCSV((toCSV(parseCSV(document.getElementById("csvInput").value, 
                                                   document.getElementById("percentCompleteMultiplier").checked, 
                                                   document.getElementById("projectStartDate").value, 
                                                   document.getElementById("todayDate").value),
                                          document.getElementById("datesFormat").value
                                         )
                                   ))'
           >Save as CSV</button>

  </div>

  <div class="tab-container">
  <div class="tab">
    <div class="tab-button active" onclick="openTab(event, 'tab1')">Project Settings</div>
    <div class="tab-button" onclick="openTab(event, 'tab2')">Chart Settings</div>
    <div class="tab-button" onclick="openTab(event, 'tab3')">Bars Settings</div>
    <div class="tab-button" onclick="openTab(event, 'tab4')">Tasks Settings</div>
    <div class="tab-button" onclick="openTab(event, 'tab5')">Dates Settings</div>
  </div>

  <div class="tab-content-container">
  <div id="tab1" class="tab-content active">
  <div id="options">
    <!--Project Settings-->

    <!-- Calendar Settings -->
    <button id="nonWorkingDates" title="Set Non-Working dates for the project" onclick="openNonWorkingDatesPopup()">Calendar</button>
    
    <!-- Project Start Date -->
    <label for="projectStartDate" title="Start date">Project Start Date:</label>
    <input type="date" id="projectStartDate" value="" onload="this.value = todayDateMinusOneMonth();" onchange="generateGanttChart()" />

    <!-- Today Date -->
    <label for="todayDate" title="Today's date">Today Date:</label>
    <input type="date" id="todayDate" value="" onload="this.value = todayDate();" onchange="generateGanttChart()" />

    <!-- Percent Complete * 100 -->
    <label for="percentCompleteMultiplier" title="Multiply Percent Complete by 100">Percent Complete *100:</label>
    <input type="checkbox" id="percentCompleteMultiplier" onchange="generateGanttChart()" />

  </div>
  </div>
  
  <div id="tab2" class="tab-content">
  <div id="options">
    <!-- Chart Settings -->

    <!-- Chart Width -->
    <label for="chartWidth" title="Width in pixels of the whole chart">Chart Width:</label>
    <input type="number" id="chartWidth" value="800" onchange="generateGanttChart()"/>
      
    <!-- Left Margin Control -->
    <label for="leftMargin" title="Distance of left margin of the whole chart form the left of the page, in pixels">Left Margin:</label>
    <input type="number" id="leftMargin" value="4" onchange="generateGanttChart()"/>

    <!-- Vertical axe 0 -->
    <label for="verticalShift" title="Zero position of the vertical axe of the Gantt chart from the left of the page, in pixels">Y Axe Zero :</label>
    <input type="number" id="verticalShift" value="232" onchange="generateGanttChart()"/>

    <!-- Offset Zero Start Date Control -->
    <label for="offsetZeroX" title="Distance of the bars from the vertical axe in the Gantt chart, in pixels">Start Date Zero:</label>
    <input type="number" id="offsetZeroX" value="84" onchange="generateGanttChart()"/>

    <!-- Right Margin -->
    <label for="rightMargin" title="Space between the right margin of the whole chart and the right of the page, in pixels">Right Margin:</label>
    <input type="number" id="rightMargin" value="96" onchange="generateGanttChart()"/><br>

    <!-- Horizontal axe 0-->
    <label for="timelineY" title="Zero position of the horizontal axe of the Gantt chart from the top of the page, in pixels">X Axe Zero:</label>
    <input type="number" id="timelineY" value="40" onchange="generateGanttChart()"/>

    <!-- Header Vertical Space -->
    <label for="headerSpaceFromTimelineY" title="Vertical spacing of header from the timeline, in pixels">Header Vert Space:</label>
    <input type="number" id="headerSpaceFromTimelineY" value="14" onchange="generateGanttChart()"/>

    <!-- Header Dates Space -->
    <label for="headerDatesSpace" title="Horizontal spacing of dates in header, in pixels. Increasing the value some dates disappear">Header Space:</label>
    <input type="number" id="headerDatesSpace" value="54" onchange="generateGanttChart()"/>
    
    <!-- Vertical Lines Color -->
    <label for="verticalLinesColor" title="Color of vertical timelines, 'None' is no vertical lines">Vertical Timelines:</label>
    <select id="verticalLinesColor" onchange="generateGanttChart()">
      <option value="none">None</option>
      <option value="black">Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="#ccc" selected>Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

    <!-- Horizontal Separators Lines Color -->
    <label for="horizontalSeparatorsColor" title="Color of lines separating the bars horizontally, in pixels, 'None' is no separator lines showed">Horizontal Separators:</label>
    <select id="horizontalSeparatorsColor" onchange="generateGanttChart()">
      <option value="none">None</option>
      <option value="black">Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="#ccc" selected>Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

  </div>
  </div>

  <div id="tab3" class="tab-content">
  <div id="options">
  
     <!--Bars Settings-->

    <!-- Bars Height -->
    <label for="barHeight" title="Height of the bars in the Gantt chart, in pixels">Height:</label>
    <input type="number" id="barHeight" value="16" onchange="generateGanttChart()"/>

    <!-- Bars Distance -->
    <label for="barSpace" title="Space between bars in the Gantt chart, in pixels">Space:</label>
    <input type="number" id="barSpace" value="16" onchange="generateGanttChart()"/>

    <!-- Color for Percent Not Complete Bars -->
    <label for="percentNotCompleteColor" title="Color of the not complete portion of the bars, 'None' is no bar showed">Bars % Not Complete:</label>
    <select id="percentNotCompleteColor" onchange="generateGanttChart()">
      <option value="none">None</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
      <option value="orange" selected>Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="black">black</option>
    </select>

    <!-- Color for Percent Complete Bars --> 
    <label for="percentCompleteColor" title="Color of the complete portion of the bars,'None' is no bar showed">% Complete:</label>
    <select id="percentCompleteColor" onchange="generateGanttChart()">
      <option value="none">None</option>
      <option value="green" selected>Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="black">black</option>
    </select>

    <!-- Color for Border of Bars -->
    <label for="strokeColor" title="Color of the bars borders, 'None' is no border showed">Border:</label>
    <select id="strokeColor" onchange="generateGanttChart()">
      <option value="none" selected>None</option>
      <option value="black">Black</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
    </select><br>

    <!-- Bars border thickness -->
    <label for="barBorderThickness" title="Thickness in pixels of bars borders, only applicable if 'Bars border' color not 'None'">Border Thickness:</label>
    <input type="number" id="barBorderThickness" value="1" onchange="generateGanttChart()"/>

    <!-- Bars angles -->
    <label for="barAngles" title="Angle size of the bars corners, 0 is 90 degrees angle applied">Angles:</label>
    <input type="number" id="barAngles" value="0" onchange="generateGanttChart()"/>

    <!-- Critical Path Line Color -->
    <label for="criticalPathLineColor" title="Color of the critical bars section within the critical bars, 'None' is no critial section is showed within the bars">Critical:</label>
    <select id="criticalPathLineColor" onchange="generateGanttChart()">
      <option value="none">None</option>
      <option value="black">Black</option>
      <option value="orange">Orange</option>
      <option value="red" selected>Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

    <!-- Critical Path Line Width -->
    <label for="criticalPathLineWidth" title="Width of the critical section within the critical bars of the critical path, only applicable if 'Critical' is not 'None'">Critical Width:</label>
    <input type="number" id="criticalPathLineWidth" value="2" onchange="generateGanttChart()"/>

    <!-- Dependecies Line Color -->
    <label for="dependenciesLineColor" title="Color of dependency lines, 'None' is no dependency lines showed">Dependencies:</label>
    <select id="dependenciesLineColor" onchange="generateGanttChart()">
      <option value="none">None</option>
      <option value="black">Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal" selected>Teal</option>
      <option value="pink">Pink</option>
    </select><br>

    <!-- Dependecies Dashed Line -->
    <label for="dependenciesLineDashed" title="Style of dependency lines, applicable only if 'Dependencies' in not 'None'">Dependencies Dashed:</label>
    <select id="dependenciesLineDashed" onchange="generateGanttChart()">
      <option value="0,0" selected>Not Dashed</option>
      <option value="4,4">Dashed</option>
    </select>
  
  </div>
  </div>

  <div id="tab4" class="tab-content">
  <div id="options">
    <!-- Tasks Settings -->

    <!-- Tasks char size -->
    <label for="tasksCharSize" title="Size of task labels text, in pixels">Size:</label>
    <input type="number" id="tasksCharSize" value="12" onchange="generateGanttChart()"/>

    <!-- Tasks char family -->
    <label for="tasksCharFamily" title="Font family of tasks labels text">Family:</label>
    <select id="tasksCharFamily" onchange="generateGanttChart()">
        <option value="Arial">Arial</option>
        <option value="Verdana">Verdana</option>
        <option value="Helvetica" selected>Helvetica</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Georgia">Georgia</option>
        <option value="Courier New">Courier New</option>
        <option value="Tahoma">Tahoma</option>
        <option value="Trebuchet MS">Trebuchet MS</option>
        <option value="Impact">Impact</option>
        <option value="Comic Sans MS">Comic Sans MS</option>
        <option value="Lucida Sans">Lucida Sans</option>
        <option value="Calibri">Calibri</option>
        <option value="Garamond">Garamond</option>
        <option value="Cambria">Cambria</option>
        <option value="Palatino">Palatino</option>
        <option value="Roboto">Roboto</option>
        <option value="Open Sans">Open Sans</option>
        <option value="Lato">Lato</option>
        <option value="Montserrat">Montserrat</option>
        <option value="Raleway">Raleway</option>
    </select>

    <!-- Tasks Char Style -->
    <label for="tasksCharStyle" title="Style of tasks labels text">Style:</label>
    <select id="tasksCharStyle" onchange="generateGanttChart()">
      <option value="normal" selected>Normal</option>
      <option value="italic">Italic</option>
      <option value="oblique">Oblique</option>
    </select>

    <!-- Tasks Char Weight -->
    <label for="tasksCharWeight" title="Weight of the tasks labels text">Weight:</label>
    <select id="tasksCharWeight" onchange="generateGanttChart()">
      <option value="normal" selected>Normal</option>
      <option value="bold">Bold</option>
      <option value="lighter">Lighter</option>
      <option value="bolder">Bolder</option>
    </select>

    <!-- Tasks Char Color -->
    <label for="tasksCharColor" title="Color of tasks labels text, 'None' is no tasks label showed. Combined with the 'Tasks Delay' color">Color:</label>
    <select id="tasksCharColor" onchange="generateGanttChart()">
      <option value="none">None</option>
      <option value="black" selected>Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select><br>

    <!-- Delayed Color -->
    <label for="delayedColor" title="Color of the delayed tasks labels, combined with 'Tasks color'">Delay:</label>
    <select id="delayedColor" onchange="generateGanttChart()">
      <!-- <option value="none">None</option> -->
      <option value="black" selected>Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

    <!-- Text Vert Align -->
    <label for="offsetDateBarV" title="Vertical alignement position of tasks and dates labels against the bars center positioning, in pixels">Y Align:</label>
    <input type="number" id="offsetDateBarV" value="10" onchange="generateGanttChart()"/>

    <!-- Tasks truncate chars -->
    <label for="tasksTruncate" title="Number of characters to truncate the task names">Trunc:</label>
    <input type="number" id="tasksTruncate" value="35" onchange="generateGanttChart()"/>

    <!-- Show detailed tasks info line 0-->
    <label for="tasksDetailedInfo_0" title="Show detailed additional task information">Actuals:</label>
    <input type="checkbox" id="tasksDetailedInfo_0" onchange="generateGanttChart()" />

    <!-- Show detailed tasks info line 1-->
    <label for="tasksDetailedInfo_1" title="Show detailed additional task information">Durations:</label>
    <input type="checkbox" id="tasksDetailedInfo_1" onchange="generateGanttChart()" />

    <!-- Show detailed tasks info line 2-->
    <label for="tasksDetailedInfo_2" title="Show detailed additional task information">Predecessors:</label>
    <input type="checkbox" id="tasksDetailedInfo_2" onchange="generateGanttChart()" />

  </div>
  </div>

  <div id="tab5" class="tab-content">
  <div id="options">
    <!-- Dates Settings -->

    <!-- Dates format -->    
    <label for="datesFormat" title="Format of dates labels text"`>Format:</label>
    <select id="datesFormat" onchange="generateGanttChart()">
      <option value="MM/DD/YYYY">MM/DD/YYYY</option>
      <option value="DD/MM/YYYY">DD/MM/YYYY</option>
      <option value="YYYY-MM-DD">YYYY-MM-DD</option>
      <option value="MMM DD, YYYY">MMM DD, YYYY</option>
      <option value="DD MMM YYYY" selected>DD MMM YYYY</option>
    </select>

    <!-- Dates char size -->
    <label for="datesCharSize" title="Size of dates labels text, in pixels">Size:</label>
    <input type="number" id="datesCharSize" value="12" onchange="generateGanttChart()"/>
    
    <!-- Dates char family -->
    <label for="datesCharFamily" title="Font family of dates labels text">Family:</label>
    <select id="datesCharFamily" onchange="generateGanttChart()">
        <option value="Arial">Arial</option>
        <option value="Verdana">Verdana</option>
        <option value="Helvetica" selected>Helvetica</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Georgia">Georgia</option>
        <option value="Courier New">Courier New</option>
        <option value="Tahoma">Tahoma</option>
        <option value="Trebuchet MS">Trebuchet MS</option>
        <option value="Impact">Impact</option>
        <option value="Comic Sans MS">Comic Sans MS</option>
        <option value="Lucida Sans">Lucida Sans</option>
        <option value="Calibri">Calibri</option>
        <option value="Garamond">Garamond</option>
        <option value="Cambria">Cambria</option>
        <option value="Palatino">Palatino</option>
        <option value="Roboto">Roboto</option>
        <option value="Open Sans">Open Sans</option>
        <option value="Lato">Lato</option>
        <option value="Montserrat">Montserrat</option>
        <option value="Raleway">Raleway</option>
    </select>

    <!-- Dates Char Style -->
    <label for="datesCharStyle" title="Style of dates labels text">Style:</label>
    <select id="datesCharStyle" onchange="generateGanttChart()">
      <option value="normal" selected>Normal</option>
      <option value="italic">Italic</option>
      <option value="oblique">Oblique</option>
    </select>

    <!-- Dates Char Weight -->
    <label for="datesCharWeight" title="Weight of dates labels text">Weight:</label>
    <select id="datesCharWeight" onchange="generateGanttChart()">
      <option value="normal" selected>Normal</option>
      <option value="bold">Bold</option>
      <option value="lighter">Lighter</option>
      <option value="bolder">Bolder</option>
    </select><br>

    <!-- Dates Char Color -->
    <label for="datesCharColor" title="Color of dates labels text, 'None' is no dates showed">Color:</label>
    <select id="datesCharColor" onchange="generateGanttChart()">
      <option value="none" selected>None</option>
      <option value="black" selected>Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>
    
    <!-- Dates Left Space -->
    <label for="offsetDateBarLeftH" title="Horizontal spacing of the dates labels from left of bars, in pixels">Left Space:</label>
    <input type="number" id="offsetDateBarLeftH" value="74" onchange="generateGanttChart()"/>

    <!-- Dates Right Space -->
    <label for="offsetDateBarRightH" title="Horizontal spacing of the dates labels from right of bars, in pixels">Right Space:</label>
    <input type="number" id="offsetDateBarRightH" value="5" onchange="generateGanttChart()"/>

  </div>
  </div>

</div>  
</div>
</div>  

<div id="svgContainer"></div>

<script>
  const svgNS = "http://www.w3.org/2000/svg";

  function openTab(event, tabId) {
    // Hide all tab content
    document.querySelectorAll('.tab-content').forEach(tab => {
      tab.classList.remove('active');
    });
    // Remove active class from all tab buttons
    document.querySelectorAll('.tab-button').forEach(btn => {
      btn.classList.remove('active');
    });
    // Show the selected tab content
    document.getElementById(tabId).classList.add('active');
    // Add active class to the clicked tab button
    event.currentTarget.classList.add('active');
  }

  document.getElementById('todayDate').value = todayDate()
  function todayDate() {
    const today = new Date();
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0'); // Month is zero-based
    const day = String(today.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`; // Format as YYYY-MM-DD
  }

  document.getElementById('projectStartDate').value = todayDateMinusOneMonth()
  function todayDateMinusOneMonth() {
    const today = new Date();
    const todayMinusOneMonth = new Date(today);
    todayMinusOneMonth.setMonth(today.getMonth() - 1);
    const year = todayMinusOneMonth.getFullYear();
    const month = String(todayMinusOneMonth.getMonth() + 1).padStart(2, '0'); // Month is zero-based
    const day = String(todayMinusOneMonth.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`; // Format as YYYY-MM-DD
    
  }

  function parseCSV(data, percentCompleteMultiplier, projectStartDate, todayDate) {
    try {
      const nonWorkingDates = getNonWorkingDatesConfig();
      let projectStart = new Date(projectStartDate);
      while (isNonWorkingDay(projectStart, nonWorkingDates)) {
        projectStart = new Date(projectStart.getTime() + 24 * 60 * 60 * 1000);
      }
      const today = new Date(todayDate);
      // Determine the separator (comma or tab) based on the first row
      const separator = data.includes('\t') ? '\t' : ',';
      // Split the data into rows
      const rows = data.trim().split('\n');
      // Map each row into a task object
      const tasks = rows.map(row => {
        const cols = row.split(separator);
        // Create Tasks object with initial values
        return {
          id: parseInt(cols[0], 10),
          name: cols[1],
          duration: parseInt(cols[2], 10),
          percentComplete: percentCompleteMultiplier ? parseFloat(cols[3])*100 : parseFloat(cols[3]),
          idealPercentComplete: 0,
          earliestStartDate: new Date(projectStart),
          earliestFinishDate: new Date(projectStart),
          latestStartDate: new Date(projectStart),
          latestFinishDate: new Date(projectStart),
          startDate: new Date(projectStart),
          endDate: new Date(projectStart),
          predecessors: cols[4] ? parsePredecessors(cols[4]) : [],
          elapsed: 0,
          totalFloat: 0,
          critical: false,
          delay: false,
          milestone: false,
          startX: 0,
          startY: 0,
          endX: 0,
          endY: 0
        };
      });

      //Search for Critical Tasks, set Dates, Floats, and Critical

      //Add original index to tasks
      tasks.forEach((task, index) => {
        task.originalIndex = index;
      });
      
      //Sort the tasks with those without predecessors at the top.
      const sortedTasks = topologicalSort(tasks); 

      // Calculate Earliest Start/Finish Times (Forward Pass)
      sortedTasks.forEach(task => {
        if (task.predecessors.length > 0) {
          const validTimestamps = task.predecessors.map(pred => {
            const predTask = sortedTasks.find(t => t.id === pred.id);
            if (!predTask) {
                console.warn(`Predecessor task not found for ID: ${pred.id}`);
                return Number.NEGATIVE_INFINITY;
            }
            const leadLag = pred.leadLag || 0;
            let calculatedDate;
            switch (pred.dependencyType) {
              case "FS": // Finish-to-Start
                calculatedDate = new Date(
                  predTask.earliestFinishDate.getTime() + getElapsed(predTask.earliestFinishDate, leadLag, nonWorkingDates) * 24 * 60 * 60 * 1000);
                break;
              case "SS": // Start-to-Start
                calculatedDate = new Date(
                  predTask.earliestStartDate.getTime() + getElapsed(predTask.earliestStartDate, leadLag, nonWorkingDates) * 24 * 60 * 60 * 1000);
                break;
              case "FF": // Finish-to-Finish
                calculatedDate = new Date(
                  predTask.earliestFinishDate.getTime() + getElapsed(predTask.earliestFinishDate, -task.duration, nonWorkingDates) * 24 * 60 * 60 * 1000 + getElapsed(predTask.earliestFinishDate, leadLag, nonWorkingDates) * 24 * 60 * 60 * 1000);
                break;
              case "SF": // Start-to-Finish
                calculatedDate = new Date(
                  predTask.earliestStartDate.getTime() + getElapsed(predTask.earliestStartDate, -task.duration, nonWorkingDates) * 24 * 60 * 60 * 1000 + getElapsed(predTask.earliestStartDate, leadLag, nonWorkingDates) * 24 * 60 * 60 * 1000);
                break;
              default:
                console.warn(`Unknown dependency type: ${pred.dependencyType}`);
                return Number.NEGATIVE_INFINITY;
            }
            return calculatedDate.getTime();
          }).filter(ts => ts !== Number.NEGATIVE_INFINITY);

          if (validTimestamps.length > 0) {
            task.earliestStartDate = new Date(Math.max(...validTimestamps));
            while (isNonWorkingDay(task.earliestStartDate, nonWorkingDates)) {
              task.earliestStartDate = new Date(task.earliestStartDate.getTime() + 24 * 60 * 60 * 1000);}

          } else {
            console.warn(`No valid predecessors for task ID: ${task.id}`);
            task.earliestStartDate = new Date(); // Fallback to another default date
          }
        }
        if (!isNaN(task.earliestStartDate)) {
          task.elapsed = getElapsed(task.earliestStartDate, task.duration, nonWorkingDates);
          task.earliestFinishDate = new Date(task.earliestStartDate.getTime() + task.elapsed * 24 * 60 * 60 * 1000);
          while (isNonWorkingDay(task.earliestFinishDate, nonWorkingDates)) {
            task.earliestFinishDate = new Date(task.earliestFinishDate.getTime() + 24 * 60 * 60 * 1000);}
        } else {
          console.error(`Invalid earliestStartDate for task ID: ${task.id}`);}
        task.startDate = task.earliestStartDate;
        task.endDate = task.earliestFinishDate;
      });

      // Calculate Latest Start/Finish Times (Backward Pass)
      const reversedTasks = [...sortedTasks].reverse();
      //const reversedTasks = sortedTasks;
      reversedTasks.forEach(task => {
        const finishCandidates = reversedTasks
          .filter(t => t.predecessors.some(p => p.id === task.id))
          .map(dep => {
            const predecessor = dep.predecessors.find(p => p.id === task.id);
            const leadLag = predecessor?.leadLag || 0;
            let calculatedDate;
            switch (predecessor?.dependencyType) {
              case "FS": // Finish-to-Start
                calculatedDate = new Date(
                  dep.latestStartDate.getTime() + getElapsed(dep.latestStartDate, -leadLag, nonWorkingDates) * 24 * 60 * 60 * 1000);
                break;
              case "SS": // Start-to-Start
                calculatedDate = new Date(
                  dep.latestStartDate.getTime() + task.elapsed * 24 * 60 * 60 * 1000 + getElapsed(dep.latestStartDate, -leadLag, nonWorkingDates) * 24 * 60 * 60 * 1000);
                break;
              case "FF": // Finish-to-Finish
                calculatedDate = new Date(
                  dep.latestFinishDate.getTime() + getElapsed(dep.latestFinishDate, -leadLag, nonWorkingDates) * 24 * 60 * 60 * 1000);
                break;
              case "SF": // Start-to-Finish
                calculatedDate = new Date(
                  dep.latestFinishDate.getTime() + task.elapsed * 24 * 60 * 60 * 1000 + getElapsed(dep.latestFinishDate, -leadLag, nonWorkingDates) * 24 * 60 * 60 * 1000);
                break;
              default:
                console.warn(`Unknown dependency type: ${predecessor?.dependencyType}`);
                calculatedDate = new Date(dep.latestStartDate.getTime() + getElapsed(dep.latestStartDate, -leadLag, nonWorkingDates) * 24 * 60 * 60 * 1000);
              }
            return calculatedDate.getTime();
          });

          if (finishCandidates.length) {
            task.latestFinishDate = new Date(Math.min(...finishCandidates));
            while (isNonWorkingDay(task.latestFinishDate, nonWorkingDates)) {
              task.latestFinishDate = new Date(task.latestFinishDate.getTime() - 24 * 60 * 60 * 1000);}
          } else {
            task.latestFinishDate = task.earliestFinishDate;}

          if (!isNaN(task.latestFinishDate)) {
            task.latestStartDate = new Date(task.latestFinishDate.getTime() - task.elapsed * 24 * 60 * 60 * 1000);
            while (isNonWorkingDay(task.latestStartDate, nonWorkingDates)) {
              task.latestStartDate = new Date(task.latestStartDate.getTime() - 24 * 60 * 60 * 1000);}
          } else {
            console.error(`Invalid latestFinishDate for task ID: ${task.id}`);}
      });

      // Find the project duration in days
      const allDates = reversedTasks.flatMap(task => [task.startDate, task.endDate]);
      const minDate = new Date(Math.min(...allDates));
      const maxDate = new Date(Math.max(...allDates));
      const projectDuration = (maxDate - minDate) / (1000 * 60 * 60 * 24);

      // Mark Critical Tasks, set Floats, Ideal Percent Complete, Delay
      reversedTasks.forEach(task => {
        // Set Total Float
        task.totalFloat = (task.latestStartDate.getTime() - task.earliestStartDate.getTime()) / 24 / 60 / 60 / 1000;
        // Find all paths of each task and evaluate their durations
        const paths = findPaths(task, reversedTasks);
        paths.forEach(path => {
          const pathDates = path.flatMap(t => [t.startDate, t.endDate]);
          const pathMinDate = new Date(Math.min(...pathDates));
          const pathMaxDate = new Date(Math.max(...pathDates));
          const pathDuration = (pathMaxDate - pathMinDate) / (1000 * 60 * 60 * 24);
          // Mark tasks in the longest path with total float === 0 as critical
          if (pathDuration >= projectDuration) { 
            path.forEach(t => {
              // Set critical task
              if (t.totalFloat===0) {
                t.critical = true;
              }
            });
          }
        });
        // Set ideal Percentage, delayed, and milestone tasks
        task.milestone = task.startDate.getTime() === task.endDate.getTime();
        const actualElapsed = Math.max(0, Math.min((today - task.startDate) / (1000 * 60 * 60 * 24), task.elapsed)); // Clamp to [0, totalDuration]
        task.idealPercentComplete = task.elapsed > 0 ? (actualElapsed / task.elapsed) * 100 : 0;
        if (task.milestone && today >= task.startDate) task.idealPercentComplete = 100;
        task.delay = task.percentComplete < task.idealPercentComplete;
      });

      //Rollback tasks to original order
      sortedTasks.sort((a, b) => a.originalIndex - b.originalIndex);
      //Remove the originalIndex property
      sortedTasks.forEach(task => {
        delete task.originalIndex;
      });
    
      //consoleLog(sortedTasks);
    
      return sortedTasks;
    } catch (error) {
      //const errorContainer = document.getElementById("errorContainer");
      alert("Error parsing the CSV Project Schedule:\nThe CSV of the Project Schedule is not formatted correctly");
      return []; // Return an empty array to prevent further issues
    }
    
    // Helper function: Topological sort
    function topologicalSort(tasks) {
      const graph = new Map();
      const inDegree = new Map();
      // Initialize the graph and in-degree map
      tasks.forEach(task => {
        graph.set(task.id, []);
        inDegree.set(task.id, 0);
      });
      // Build the graph and calculate in-degrees
      tasks.forEach(task => {
        task.predecessors.forEach(pred => {
          if (graph.has(pred.id)) {
            graph.get(pred.id).push(task.id);
            inDegree.set(task.id, (inDegree.get(task.id) || 0) + 1);
          }
        });
      });
      // Perform topological sorting using Kahn's algorithm
      const sortedTasks = [];
      const queue = [];
      // Start with nodes that have no incoming edges
      inDegree.forEach((degree, id) => {
        if (degree === 0) queue.push(id);
      });
      while (queue.length > 0) {
        const current = queue.shift();
        sortedTasks.push(current);
        // Reduce the in-degree of neighbors
        graph.get(current).forEach(neighbor => {
          inDegree.set(neighbor, inDegree.get(neighbor) - 1);
          if (inDegree.get(neighbor) === 0) queue.push(neighbor);
        });
      }
      return sortedTasks.map(id => tasks.find(task => task.id === id));
    }
        
    // Helper function to find paths recursively
    function findPaths(task, tasks, visited = new Set(), currentPath = []) {
      if (visited.has(task.id)) { // Prevent cycles
        alert("Error parsing the CSV Project Schedule:\nLoop within the dependencies");
        throw new Error();
        return [];
      }
      visited.add(task.id);
      currentPath.push(task);
      const successors = tasks.filter(t =>
        t.predecessors.some(p => p.id === task.id)
      );
      if (successors.length === 0) {
        // End of a path
        return [currentPath];
      }
      let paths = [];
      for (const successor of successors) {
        paths = paths.concat(findPaths(successor, tasks, new Set(visited), [...currentPath]));
      }
      return paths;
    }    

  }

  // Utility function to check if a day is non-working
  function isNonWorkingDay(date, nonWorkingDatesConfig) {
    const day = date.getDay(); // 0: Sunday, 6: Saturday
    const formattedDate = date.toISOString().split('T')[0]; // Format as YYYY-MM-DD
    return (
        (nonWorkingDatesConfig.saturdayNonWorking && day === 6) ||
        (nonWorkingDatesConfig.sundayNonWorking && day === 0) ||
        nonWorkingDatesConfig.nonWorkingDates.includes(formattedDate)
    );
  }

  function getElapsed(startDate, duration, nonWorkingDatesConfig) {
    const { saturdayNonWorking, sundayNonWorking, nonWorkingPeriods, nonWorkingDates } = nonWorkingDatesConfig;
    let elapsedDays = 0;
    let workingDaysAdded = 0;
    let currentDate = new Date(startDate);
    if (duration >= 0) {
      // Forward calculation for positive or zero duration
      while (workingDaysAdded < duration) {
        elapsedDays++;
        currentDate.setDate(currentDate.getDate() + 1); // Move to the next day
        if (!isNonWorkingDay(currentDate, nonWorkingDatesConfig)) {
          workingDaysAdded++;
        }
      }
      // Ensure the final date is a working day
      while (isNonWorkingDay(currentDate, nonWorkingDatesConfig)) {
        currentDate.setDate(currentDate.getDate() + 1);
        elapsedDays++;
      }
    } else {
      // Backward calculation for negative duration
      while (workingDaysAdded > duration) {
        elapsedDays--;
        currentDate.setDate(currentDate.getDate() - 1); // Move to the previous day
        if (!isNonWorkingDay(currentDate, nonWorkingDatesConfig)) {
          workingDaysAdded--;
        }
      }
      // Ensure the final date is a working day
      while (isNonWorkingDay(currentDate, nonWorkingDatesConfig)) {
        currentDate.setDate(currentDate.getDate() - 1);
        elapsedDays--;
      }
    }
    return elapsedDays;
  }

  function consoleLog(tasks) {
    tasks.forEach(task => {
        console.log(
          "id: "+task.id+"\n"+
          "name: "+task.name+"\n"+
          "duration: "+task.duration+"\n"+
          "percentComplete: "+task.percentComplete+"\n"+
          "idealPercentComplete: "+task.idealPercentComplete+"\n"+
          "earliestStartDate: "+task.earliestStartDate+"\n"+
          "earliestFinishDate: "+task.earliestFinishDate+"\n"+
          "latestStartDate: "+task.latestStartDate+"\n"+
          "latestFinishDate: "+task.latestFinishDate+"\n"+
          "startDate: "+task.startDate+"\n"+
          "endDate: "+task.endDate+"\n"+
          "predecessors: "+task.predecessors.map(p => String(p.id) + " " + String(p.dependencyType) + " " + String(p.leadLag))+"\n"+
          "elapsed: "+task.elapsed+"\n"+
          "totalFloat: "+task.totalFloat+"\n"+
          "critical: "+task.critical+"\n"+
          "delay: "+task.delay+"\n"+
          "milestone: "+task.milestone+"\n"+
          "startX: "+task.startX+"\n"+
          "startY: "+task.startY+"\n"+
          "endX: "+task.endX+"\n"+
          "endY: "+task.endY+"\n"
        )
    })
  }

  function toCSV(tasks, datesFormat) {
    CSV = "Id, Name, Duration, Elapsed Duration, Total Float, Percent Complete, Ideal Percent Complete, Earlier Start Date, Earliest Finish Date, Latest Start Date, Latest Finish Date, Start Date, Finish Date, Predecessors, Critical, Delay, Milestone\n";
    tasks.forEach(task => {
        CSV = CSV + 
          String(task.id)+","+
          String(task.name)+","+
          String(task.duration)+","+
          String(task.elapsed)+","+
          String(task.totalFloat)+","+
          String(task.percentComplete)+","+
          String(task.idealPercentComplete)+","+
          String(formatDate(task.earliestStartDate, datesFormat))+","+
          String(formatDate(task.earliestFinishDate, datesFormat))+","+
          String(formatDate(task.latestStartDate, datesFormat))+","+
          String(formatDate(task.latestFinishDate, datesFormat))+","+
          String(formatDate(task.startDate, datesFormat))+","+
          String(formatDate(task.endDate, datesFormat))+","+
          String(task.predecessors.map(p => String(p.id) + String(p.dependencyType) + String(p.leadLag)).join(";")) + "," +
          String(task.critical)+","+
          String(task.delay)+","+
          String(task.milestone)+"\n";
    })
    return CSV
  }

  function parsePredecessors(predecessors) {
      const regex = /\b(\d+)([FS]{2})?(?:([+-]?\d+)\s*(?:day(?:s)?)?)?\b/g;
      const result = [];
      let match;
      while ((match = regex.exec(predecessors)) !== null) {
          result.push({
              id: parseInt(match[1], 10),
              dependencyType: match[2] || "FS",
              leadLag: match[3] ? parseInt(match[3], 10) : 0
          });
      }
      return result;
  }

  function calculateTimeline(tasks) {
    try {
       const uniqueStartDates = Array.from(new Set(tasks.map(t => t.startDate.toISOString().split('T')[0])))
         .map(d => new Date(d))
         .sort((a, b) => a - b);
       const minDate = new Date(Math.min(...uniqueStartDates));
       const maxDate = new Date(Math.max(...tasks.map(t => t.endDate)));
       return { minDate, maxDate, uniqueStartDates };
    } catch (error) {
       //const errorContainer = document.getElementById("errorContainer");
       alert("Error calculating the timeline:\nThe CSV of the Project Schedule is not formatted correctly");
       return null; // Return an empty object to prevent further issues
     }  
  }

  async function exportGanttChartAsSVG() {
    try {
      const svgElement = document.getElementById("ganttChart");

      if (!svgElement) {
         alert("No Gantt chart found to export!\nView the Gantt Chart before exporting it to SVG");
         return;
      }
      // Clone the SVG element to avoid modifying the original
      const clonedSvg = svgElement.cloneNode(true);
      // Ensure the exported SVG includes the current viewBox
      const viewBox = svgElement.getAttribute("viewBox");
      if (viewBox) {
        clonedSvg.setAttribute("viewBox", viewBox);
      }
      // Serialize the SVG element to a string
      const serializer = new XMLSerializer();
      //const svgContent = serializer.serializeToString(svgElement);
      const svgContent = serializer.serializeToString(clonedSvg);
      // Create a blob with the SVG content and a downloadable link
      const blob = new Blob([svgContent], { type: "image/svg+xml" });
      //const link = document.createElement("a");

      if (window.showSaveFilePicker) {
        const fileHandle = await window.showSaveFilePicker({
          suggestedName: "gantt_chart.svg",
            types: [{
                   description: "SVG File",
                   accept: { "image/svg+xml": [".svg"] }
                   }]
          });
        // Create a writable stream and write the CSV to the file
        const writableStream = await fileHandle.createWritable();
        await writableStream.write(blob);
        await writableStream.close();
        alert("File saved successfully!");
      } else {
            // Fallback: Create a temporary <a> element for downloading
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "gantt_chart.svg";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            alert("File downloaded successfully!");
        }        
    } catch (error) {
      console.error("Error saving SVG file:", error);
      alert("Failed to save file. Make sure your browser supports the File System Access API.");
    } 
  }


  function formatDate(date, format) {
    const formatLocaleMapping = {
      "MM/DD/YYYY": "en-US", // US English
      "DD/MM/YYYY": "en-GB", // British English
      "YYYY-MM-DD": "ja-JP", // Japanese
      "MMM DD, YYYY": "en-US", // US English
      "DD MMM YYYY": "en-GB", // British English
    };
    const locale = formatLocaleMapping[format] || "en-US"; // Default to US English
    const options = {
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
    };

    switch (format) {
      case "MM/DD/YYYY":
        return date.toLocaleDateString(locale, options); // Default order in en-US
      case "DD/MM/YYYY":
        return date.toLocaleDateString(locale, options); // Default order in en-GB
      case "YYYY-MM-DD":
        return date.toLocaleDateString(locale, options).replace(/\//g, "-"); // Adapt for ja-JP style
      case "MMM DD, YYYY":
        return date.toLocaleDateString(locale, { year: "numeric", month: "short", day: "2-digit" });
      case "DD MMM YYYY":
        const [day, month, year] = date
          .toLocaleDateString(locale, { year: "numeric", month: "short", day: "2-digit" })
          .split(" ");
        return `${day} ${month} ${year}`;
      default:
        return date.toLocaleDateString(locale); // Fallback to locale default
    }
  }

  function createGanttChart(tasks, minDate, maxDate, uniqueStartDates, options) {
    const {leftMargin, 
           verticalShift, 
           offsetZeroX, 
           chartWidth, 
           rightMargin, 
           barHeight, 
           barSpace, 
           percentCompleteColor, 
           percentNotCompleteColor,
           strokeColor,
           barBorderThickness,
           barAngles,
           verticalLinesColor,
           horizontalSeparatorsColor,
           tasksCharSize,
           tasksCharFamily,
           tasksCharStyle,
           tasksCharWeight,
           tasksCharColor,
           tasksTruncate,
           tasksDetailedInfo_0,
           tasksDetailedInfo_1,
           tasksDetailedInfo_2,
           datesCharSize,
           datesCharFamily,
           datesFormat,
           datesCharStyle,
           datesCharWeight,
           datesCharColor,
           dependenciesLineColor,
           dependenciesLineDashed,
           criticalPathLineColor,
           criticalPathLineWidth,
           delayedColor,
           timelineY,
           offsetDateBarV,
           offsetDateBarLeftH,
           offsetDateBarRightH,
           headerSpaceFromTimelineY,
           headerDatesSpace } = options;

    const svg = document.createElementNS(svgNS, "svg");

    const totalWidth = chartWidth + leftMargin + verticalShift + offsetZeroX + rightMargin;
    let lastXPosition = -Infinity;

    const barDistance = barHeight + barSpace;
    const chartHeight = tasks.length * barDistance;
    const bottomMargin = 50;
    const totalHeight = chartHeight + timelineY + barDistance + bottomMargin + headerSpaceFromTimelineY;

    svg.setAttribute("id", "ganttChart");
    const viewBox = "0 0 " + totalWidth.toString() + " " + totalHeight.toString();
    svg.setAttribute("viewBox", viewBox);
    svg.setAttribute("preserveAspectRatio", "xMinYMin meet");

    const totalDays = (maxDate - minDate) / (1000 * 60 * 60 * 24);
    
    // Timeline at the top
    uniqueStartDates.forEach(date => {
      const x = (leftMargin + verticalShift + offsetZeroX + (date - minDate) / (1000 * 60 * 60 * 24) / totalDays * chartWidth);
      
      // Avoid overlapping date labels by checking lastXPosition
      if (x - lastXPosition > headerDatesSpace) { // Ensure at least 50px space between dates
        const dateLabel = document.createElementNS(svgNS, "text");
        dateLabel.setAttribute("x", x);
        dateLabel.setAttribute("y", timelineY - headerSpaceFromTimelineY);
        dateLabel.setAttribute("font-size", datesCharSize);
        dateLabel.setAttribute("font-family", datesCharFamily);
        dateLabel.setAttribute("font-style", datesCharStyle);
        dateLabel.setAttribute("font-weight", datesCharWeight);
        dateLabel.setAttribute("fill", datesCharColor);
        dateLabel.textContent = formatDate(date, datesFormat);
        svg.appendChild(dateLabel);
        lastXPosition = x;
      }

      // Draw timeline vertical lines
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", x);
      line.setAttribute("y1", timelineY);
      line.setAttribute("x2", x);
      line.setAttribute("y2", chartHeight + timelineY);
      line.setAttribute("stroke", verticalLinesColor);
      line.setAttribute("stroke-width", "1");
      svg.appendChild(line);
    });

    // Tasks title
    const tasksTitle = document.createElementNS(svgNS, "text");
    tasksTitle.setAttribute("x", leftMargin + 2); // Align to the left of the vertical bar
    tasksTitle.setAttribute("y", timelineY - headerSpaceFromTimelineY - datesCharSize); // Align to the top of the horizontal bar
    tasksTitle.setAttribute("font-size", tasksCharSize);
    tasksTitle.setAttribute("font-family", tasksCharFamily);
    tasksTitle.setAttribute("font-style", tasksCharStyle);
    tasksTitle.setAttribute("font-weight", "bold");
    tasksTitle.setAttribute("fill", tasksCharColor);
    tasksTitle.textContent = `Id, Task Name`;
    if (tasksDetailedInfo_0) tasksTitle.textContent = tasksTitle.textContent + `, Actual %, Ideal %`;   

    if (tasksDetailedInfo_1) {
      const tasksTitleDetailed = document.createElementNS(svgNS, "text");
      tasksTitleDetailed.setAttribute("x", leftMargin + 2);
      tasksTitleDetailed.setAttribute("y", timelineY - headerSpaceFromTimelineY - datesCharSize + tasksCharSize + 4);
      tasksTitleDetailed.setAttribute("font-size", tasksCharSize);
      tasksTitleDetailed.setAttribute("font-family", tasksCharFamily);
      tasksTitleDetailed.setAttribute("font-style", tasksCharStyle);
      tasksTitleDetailed.setAttribute("font-weight", "bold");
      tasksTitleDetailed.setAttribute("fill", tasksCharColor);
      tasksTitleDetailed.textContent = `Duration, Elapsed, Total Float`;
      svg.appendChild(tasksTitleDetailed);
    }

    if (tasksDetailedInfo_2) {
      const tasksTitleDetailedMore = document.createElementNS(svgNS, "text");
      tasksTitleDetailedMore.setAttribute("x", leftMargin + 2);
      if (tasksDetailedInfo_1) tasksTitleDetailedMore.setAttribute("y", timelineY - headerSpaceFromTimelineY - datesCharSize + (tasksCharSize + 4) * 2);
      else tasksTitleDetailedMore.setAttribute("y", timelineY - headerSpaceFromTimelineY - datesCharSize + tasksCharSize + 4);
      tasksTitleDetailedMore.setAttribute("font-size", tasksCharSize);
      tasksTitleDetailedMore.setAttribute("font-family", tasksCharFamily);
      tasksTitleDetailedMore.setAttribute("font-style", tasksCharStyle);
      tasksTitleDetailedMore.setAttribute("font-weight", "bold");
      tasksTitleDetailedMore.setAttribute("fill", tasksCharColor);
      tasksTitleDetailedMore.textContent = `Predecessors`;
      svg.appendChild(tasksTitleDetailedMore);
    }   
    svg.appendChild(tasksTitle);

    // Horizontal timeline line
    const timeLine = document.createElementNS(svgNS, "line");
    timeLine.setAttribute("x1", leftMargin + verticalShift);
    timeLine.setAttribute("y1", timelineY);
    timeLine.setAttribute("x2", (leftMargin + verticalShift + offsetZeroX + (maxDate - minDate) / (1000 * 60 * 60 * 24) / totalDays * chartWidth));
    timeLine.setAttribute("y2", timelineY);
    timeLine.setAttribute("stroke", "black");
    timeLine.setAttribute("stroke-width", "2");
    svg.appendChild(timeLine);

    // Vertical bar at the start of the timeline
    const verticalBar = document.createElementNS(svgNS, "line");
    verticalBar.setAttribute("x1", leftMargin + verticalShift);
    verticalBar.setAttribute("y1", timelineY);
    verticalBar.setAttribute("x2", leftMargin + verticalShift);
    verticalBar.setAttribute("y2", chartHeight + timelineY);
    verticalBar.setAttribute("stroke", "black");
    verticalBar.setAttribute("stroke-width", "2");
    svg.appendChild(verticalBar);

    // Task bars creation
    tasks.forEach((task, index) => {
      const totalWidth = ((task.endDate - task.startDate) / (1000 * 60 * 60 * 24)) / totalDays * chartWidth;
      const widthComplete = totalWidth * (task.percentComplete / 100);
      const x = leftMargin + verticalShift + offsetZeroX + ((task.startDate - minDate) / (1000 * 60 * 60 * 24)) / totalDays * chartWidth;
      const y = timelineY + 20 + index * barDistance; // Adjusted bar vertical position
      
      // Draw the bar correlated to the current task
      drawBar(x, y, totalWidth, widthComplete, task);
      
      // For each task memorize coordinate x,y to use in dependecies drawing
      task.startX = x;
      task.startY = y + barHeight - 2;
      task.endX = x + totalWidth;
      task.endY = y + barHeight - 2;
      if (task.milestone) {
        task.startX = x - totalWidth;
        task.startY = y + barHeight / 2;
        task.endX = x + barHeight / 2;
        task.endY = y + barHeight / 2;
      }  
    });

    //Draw dependencies
    drawDependencyPath(tasks, svg);

    document.getElementById("svgContainer").innerHTML = ""; // Clear previous SVGs
    document.getElementById("svgContainer").appendChild(svg);

    // Helper function to create task bars or milestone circles
    function drawBar(x, y, totalWidth, widthComplete, task) {

      //Task detailed information to show in Title elements of the SVG
      const taskDetails = (task.milestone ? "Milestone details:\n\n" : "Task details:\n\n")+
                          "id: "+task.id+"\n"+
                          "name: "+task.name+"\n"+
                          "duration: "+task.duration+"\n"+
                          "elapsed: "+task.elapsed+"\n"+
                          "percent complete: "+task.percentComplete+"\n"+
                          "ideal percent complete: "+task.idealPercentComplete+"\n"+
                          "earliest start date: "+formatDate(task.earliestStartDate,datesFormat)+"\n"+
                          "earliest finish date: "+formatDate(task.earliestFinishDate,datesFormat)+"\n"+
                          "latest start date: "+formatDate(task.latestStartDate, datesFormat)+"\n"+
                          "latest finish date: "+formatDate(task.latestFinishDate,datesFormat)+"\n"+
                          "start date: "+formatDate(task.startDate,datesFormat)+"\n"+
                          "end date: "+formatDate(task.endDate,datesFormat)+"\n"+
                          "predecessors: "+task.predecessors.map(p => String(p.id) + " " + String(p.dependencyType) + " " + String(p.leadLag))+"\n"+
                          "total float: "+task.totalFloat+"\n"+
                          "is critical: "+task.critical+"\n"+
                          "is delay: "+task.delay+"\n"+
                          "is milestone: "+task.milestone

      if (task.milestone) {
        // Draw milestone as a rhombus
        const milestoneRhombus = document.createElementNS(svgNS, "rect");
        const rhombusWidth = barHeight / 2;
        const rhombusHeight = barHeight / 2;
        const rhombusCenterX = x + rhombusWidth / 2;
        const rhombusCenterY = y + barHeight / 2;        
        milestoneRhombus.setAttribute("x", x);
        milestoneRhombus.setAttribute("y", y + barHeight / 2 - rhombusHeight / 2); // center the rhombus vertically
        milestoneRhombus.setAttribute("width", rhombusHeight);
        milestoneRhombus.setAttribute("height", rhombusHeight);
        milestoneRhombus.setAttribute("fill", "black");
        milestoneRhombus.setAttribute("transform", `rotate(45 ${rhombusCenterX} ${rhombusCenterY})`);

        // Milestone data showed as Title of SVG circle on mouse over
        const titleMilestone = document.createElementNS(svgNS, "title");
        titleMilestone.textContent = taskDetails; 
        milestoneRhombus.appendChild(titleMilestone);

        svg.appendChild(milestoneRhombus);

        // Add end date to the right of the milestone
        const endText = document.createElementNS(svgNS, "text");
        endText.setAttribute("x", x + offsetDateBarRightH + rhombusWidth + 3);
        endText.setAttribute("y", y + offsetDateBarV);
        endText.setAttribute("font-size", datesCharSize);
        endText.setAttribute("font-family", datesCharFamily);
        endText.setAttribute("font-style", datesCharStyle);
        endText.setAttribute("font-weight", datesCharWeight);
        endText.setAttribute("fill", datesCharColor);
        endText.textContent = formatDate(task.endDate,datesFormat);
        svg.appendChild(endText);

      } else {
        // Bar whitout percent complete portion
        const notCompleteRect = document.createElementNS(svgNS, "rect");
        notCompleteRect.setAttribute("x", x);
        notCompleteRect.setAttribute("y", y);
        notCompleteRect.setAttribute("width", totalWidth);
        notCompleteRect.setAttribute("height", barHeight);
        notCompleteRect.setAttribute("fill", percentNotCompleteColor);

        notCompleteRect.setAttribute("stroke", strokeColor); 
        notCompleteRect.setAttribute("stroke-width", barBorderThickness); 
        notCompleteRect.setAttribute("rx", barAngles); 
        notCompleteRect.setAttribute("ry", barAngles); 

        // Task data showed as Title of bar SVG rect on mouse over
        const titleNotCompleteRect = document.createElementNS(svgNS, "title");
        titleNotCompleteRect.textContent = taskDetails; 
        notCompleteRect.appendChild(titleNotCompleteRect);

        svg.appendChild(notCompleteRect);

        // Portion for percent complete
        const completeRect = document.createElementNS(svgNS, "rect");
        completeRect.setAttribute("x", x);
        completeRect.setAttribute("y", y);
        completeRect.setAttribute("width", widthComplete);
        completeRect.setAttribute("height", barHeight);
        completeRect.setAttribute("fill", percentCompleteColor);

        completeRect.setAttribute("stroke", strokeColor); 
        completeRect.setAttribute("stroke-width", barBorderThickness); 
        completeRect.setAttribute("rx", barAngles); 
        completeRect.setAttribute("ry", barAngles); 

        // Task data showed as Title of bar SVG rect on mouse over
        const titleCompleteRect = document.createElementNS(svgNS, "title");
        titleCompleteRect.textContent = taskDetails; 
        completeRect.appendChild(titleCompleteRect);

        svg.appendChild(completeRect);

        // Critical path
        if (task.critical) {
          const criticalRect = document.createElementNS(svgNS, "rect");
          criticalRect.setAttribute("x", x);
          criticalRect.setAttribute("y", y + (barHeight - criticalPathLineWidth)/2);
          criticalRect.setAttribute("width", totalWidth);
          criticalRect.setAttribute("height", criticalPathLineWidth);
          criticalRect.setAttribute("fill", criticalPathLineColor);

          criticalRect.setAttribute("rx", barAngles); 
          criticalRect.setAttribute("ry", barAngles); 

          // Task data showed as Title of critical SVG bar on mouse over
          const titleCriticalRect = document.createElementNS(svgNS, "title");
          titleCriticalRect.textContent = taskDetails; 
          criticalRect.appendChild(titleCriticalRect);

          svg.appendChild(criticalRect);
        }

        // Task start and end date labels
        const startText = document.createElementNS(svgNS, "text");
        startText.setAttribute("x", x - offsetDateBarLeftH); 
        startText.setAttribute("y", y + offsetDateBarV);
        startText.setAttribute("font-size", "10");
        startText.setAttribute("fill", "black");
        startText.setAttribute("font-size", datesCharSize);
        startText.setAttribute("font-family", datesCharFamily);
        startText.setAttribute("font-style", datesCharStyle);
        startText.setAttribute("font-weight", datesCharWeight);
        startText.setAttribute("fill", datesCharColor);
        startText.textContent = formatDate(task.startDate, datesFormat);
        svg.appendChild(startText);

        const endText = document.createElementNS(svgNS, "text");
        endText.setAttribute("x", x + totalWidth + offsetDateBarRightH);
        endText.setAttribute("y", y + offsetDateBarV);
        endText.setAttribute("font-size", datesCharSize);
        endText.setAttribute("font-family", datesCharFamily);
        endText.setAttribute("font-style", datesCharStyle);
        endText.setAttribute("font-weight", datesCharWeight);
        endText.setAttribute("fill", datesCharColor);
        endText.textContent = formatDate(task.endDate, datesFormat);
        svg.appendChild(endText);
      }

      // Add primary task info to the left of the vertical bar
      const nameText = document.createElementNS(svgNS, "text");
      nameText.setAttribute("x", leftMargin + 2); // Align to the left of the vertical bar
      nameText.setAttribute("y", y + offsetDateBarV - Number(tasksDetailedInfo_1 && tasksDetailedInfo_2) * tasksCharSize);
      nameText.setAttribute("font-size", tasksCharSize);
      nameText.setAttribute("font-family", tasksCharFamily);
      nameText.setAttribute("font-style", tasksCharStyle);
      nameText.setAttribute("font-weight", tasksCharWeight);
      nameText.setAttribute("fill", tasksCharColor);
      if (task.delay && (tasksCharColor != "none")) nameText.setAttribute("fill", delayedColor);
      const truncatedTaskName = (String(task.name).length < tasksTruncate && String(task.name).length>0) ? 
                                 String(task.name) : 
                                (String(task.name).slice(0, tasksTruncate) + "...");
      nameText.textContent = `${task.id}, ${truncatedTaskName}`;
      if (tasksDetailedInfo_0) nameText.textContent = nameText.textContent + `, ${Math.round(task.percentComplete)}%, ${Math.round(task.idealPercentComplete)}%`;

      // Task data showed as Title of tasks SVG text on mouse over
      const titleNameText = document.createElementNS(svgNS, "title");
      titleNameText.textContent = taskDetails; 
      nameText.appendChild(titleNameText);
      svg.appendChild(nameText);

      //Add detailed Task info in the line below if needed 
      if (tasksDetailedInfo_1) {
         const detailedText = document.createElementNS(svgNS, "text");
         detailedText.setAttribute("x", leftMargin + 16); // Align to the left of the vertical bar
         detailedText.setAttribute("y", y + 2 + offsetDateBarV + tasksCharSize - Number(tasksDetailedInfo_2) * tasksCharSize); //Space for the line below
         detailedText.setAttribute("font-size", tasksCharSize);
         detailedText.setAttribute("font-family", tasksCharFamily);
         detailedText.setAttribute("font-style", tasksCharStyle);
         detailedText.setAttribute("font-weight", tasksCharWeight);
         detailedText.setAttribute("fill", tasksCharColor);
         if (task.delay && (tasksCharColor != "none")) detailedText.setAttribute("fill", delayedColor);
         detailedText.textContent = `${task.duration}, ${task.elapsed}, ${task.totalFloat}`;
         const titleNameText = document.createElementNS(svgNS, "title");
         titleNameText.textContent = taskDetails; 
         detailedText.appendChild(titleNameText);
         svg.appendChild(detailedText);
      }
      
      //Add detailed Task info in the second line below if needed
      if (tasksDetailedInfo_2) {
         const detailedTextMore = document.createElementNS(svgNS, "text");
         detailedTextMore.setAttribute("x", leftMargin + 16); // Align to the left of the vertical bar
         detailedTextMore.setAttribute("y", y + 4 + offsetDateBarV + tasksCharSize); //Space for the two lines below
         detailedTextMore.setAttribute("font-size", tasksCharSize);
         detailedTextMore.setAttribute("font-family", tasksCharFamily);
         detailedTextMore.setAttribute("font-style", tasksCharStyle);
         detailedTextMore.setAttribute("font-weight", tasksCharWeight);
         detailedTextMore.setAttribute("fill", tasksCharColor);
         if (task.delay && (tasksCharColor != "none")) detailedTextMore.setAttribute("fill", delayedColor);
         detailedTextMore.textContent = ' ';
         task.predecessors.
           forEach(p => { 
            detailedTextMore.textContent = detailedTextMore.textContent + `${p.id}${p.dependencyType} ${p.leadLag}, `;
         });
         detailedTextMore.textContent = detailedTextMore.textContent.replace(/, $/, ''); //remove the final comma
         detailedTextMore.textContent = (detailedTextMore.textContent.length < tasksTruncate && detailedTextMore.textContent.length > 0) ?
                                         detailedTextMore.textContent : 
                                        (detailedTextMore.textContent.slice(0, tasksTruncate) + "...");
         const titleNameTextMore = document.createElementNS(svgNS, "title");
         titleNameTextMore.textContent = taskDetails; 
         detailedTextMore.appendChild(titleNameTextMore);
         svg.appendChild(detailedTextMore);
      }

      // Horizontal line separator
      const lineSeparator = document.createElementNS(svgNS, "line");
      lineSeparator.setAttribute("x1", leftMargin + 2);
      lineSeparator.setAttribute("y1", y + barHeight + 8);
      lineSeparator.setAttribute("x2", (leftMargin + verticalShift + offsetZeroX + (maxDate - minDate) / (1000 * 60 * 60 * 24) / totalDays * chartWidth));
      lineSeparator.setAttribute("y2", y + barHeight + 8);
      lineSeparator.setAttribute("stroke", horizontalSeparatorsColor);
      lineSeparator.setAttribute("stroke-width", "1");
      svg.appendChild(lineSeparator);

    }

    // Helper function to create dependencies of a task bar
    function drawDependencyPath(tasks, svg) {
      // Draw marker arrow
      const marker = document.createElementNS(svgNS, "marker");
      marker.setAttribute("id", "arrow");
      marker.setAttribute("markerWidth", "10");
      marker.setAttribute("markerHeight", "10");
      marker.setAttribute("refX", "10");
      marker.setAttribute("refY", "5");
      marker.setAttribute("orient", "auto-start-reverse");
      marker.setAttribute("markerUnits", "strokeWidth");
      const arrow = document.createElementNS(svgNS, "path");
      arrow.setAttribute("d", "M0,0 L10,5 L0,10 L4,5 Z");
      arrow.setAttribute("fill", dependenciesLineColor);
      marker.appendChild(arrow);
      svg.appendChild(marker);
      
      //Draw dependencies for each task with dependecies in tasks
      tasks.forEach((task, index) => {
         const isDependent = task.predecessors.length != 0;
         if (isDependent) {
         task.predecessors.forEach(dep => {
             const fromTask = tasks.find(t => t.id === dep.id);
             const toTask = task;
             if (fromTask && toTask) {
               const path = document.createElementNS(svgNS, "path");
               // Set x,and y values of the dependecy lines on the base of the type of dependency
               fromX = 0;
               fromY = 0;
               toX = 0;
               toY = 0;
               if (dep.dependencyType==="FS" || dep.dependencyType===null) {
                 fromX = fromTask.endX;
                 fromY = fromTask.endY;
                 toX = toTask.startX;
                 toY = toTask.startY;
                 // Draw the dependency line path FS type
                 path.setAttribute("d", `M ${fromX} ${fromY} H ${fromX + offsetDateBarRightH} V ${fromY + (barHeight/2)} H ${toX - offsetDateBarLeftH - 2} V ${toY} H ${toX}`);
               } else if (dep.dependencyType==="FF") {
                 fromX = fromTask.endX;
                 fromY = fromTask.endY;
                 toX = toTask.endX;
                 toY = toTask.endY;   
                 // Draw the dependency line path FF type
                 path.setAttribute("d", `M ${fromX} ${fromY} H ${toX + offsetDateBarRightH + offsetDateBarLeftH} V ${toY} H ${toX}`);
               } else if (dep.dependencyType==="SF") {
                 fromX = fromTask.startX;
                 fromY = fromTask.startY;
                 toX = toTask.endX;
                 toY = toTask.endY;   
                 // Draw the dependency line path SF type
                 path.setAttribute("d", `M ${fromX} ${fromY} H ${fromX - offsetDateBarLeftH -2} V ${fromY + (barHeight/2)} H ${toX + offsetDateBarRightH + offsetDateBarLeftH} V ${toY} H ${toX}`);
               } else if (dep.dependencyType==="SS"){
                 fromX = fromTask.startX;
                 fromY = fromTask.startY;
                 toX = toTask.startX;
                 toY = toTask.startY;
                 // Draw the dependency line path SS type
                 path.setAttribute("d", `M ${fromX} ${fromY} H ${fromX - offsetDateBarLeftH -2} V ${toY} H ${toX}`);
               }
               path.setAttribute("stroke", dependenciesLineColor);
               path.setAttribute("stroke-width", "1");
               path.setAttribute("stroke-dasharray", dependenciesLineDashed);
               path.setAttribute("fill", "none");
               path.setAttribute("marker-end", "url(#arrow)");
               svg.appendChild(path);
             }  
           })    
         }
      })
    }
  }

  // Global configuration object to store non-working dates
  window.NonWorkingDatesConfig = {
      config: null,
      setConfig: function(config) {
          this.config = config;
      },
      getConfig: function() {
          return this.config;
      }
  };
      
  // Global function to retrieve non-working dates configuration
  function getNonWorkingDatesConfig() {
      const currentConfig = window.NonWorkingDatesConfig.getConfig();
      // If no configuration exists, return a default configuration
      if (!currentConfig) {
          return {
              saturdayNonWorking: true,
              sundayNonWorking: true,
              nonWorkingPeriods: [],
              nonWorkingDates: []
          };
      }
      // Otherwise, return the existing configuration
      return currentConfig;
  }

  // Global function to set non-working dates configuration
  function setNonWorkingDatesConfig(nonWorkingConfig) {
    window.NonWorkingDatesConfig.setConfig(nonWorkingConfig);
  }

  // Global function to create the non-working dates popup user interface
  function createNonWorkingDatesPopup() {
      //retrieve possible non-working dates existing configurations
      const existingNonWorkingDatesConfig = getNonWorkingDatesConfig();

      // Create popup overlay
      const overlay = document.createElement('div');
      overlay.classList.add('popup-overlay');

      // Create popup container
      const popup = document.createElement('div');
      popup.classList.add('popup-container');

      // Checkbox section
      const checkboxSection = document.createElement('div');
      checkboxSection.classList.add('checkbox-section');

      // Saturday checkbox
      const saturdayCheckbox = document.createElement('input');
      saturdayCheckbox.type = 'checkbox';
      saturdayCheckbox.id = 'saturday-non-working';
      saturdayCheckbox.checked = existingNonWorkingDatesConfig.saturdayNonWorking;

      const saturdayLabel = document.createElement('label');
      saturdayLabel.htmlFor = 'saturday-non-working';
      saturdayLabel.appendChild(document.createTextNode('Saturday non-working'));

      checkboxSection.appendChild(saturdayCheckbox);
      checkboxSection.appendChild(saturdayLabel);
      checkboxSection.appendChild(document.createElement('br'));

      // Sunday checkbox
      const sundayCheckbox = document.createElement('input');
      sundayCheckbox.type = 'checkbox';
      sundayCheckbox.id = 'sunday-non-working';
      sundayCheckbox.checked = existingNonWorkingDatesConfig.sundayNonWorking;

      const sundayLabel = document.createElement('label');
      sundayLabel.htmlFor = 'sunday-non-working';
      sundayLabel.appendChild(document.createTextNode('Sunday non-working'));

      checkboxSection.appendChild(sundayCheckbox);
      checkboxSection.appendChild(sundayLabel);

      popup.appendChild(checkboxSection);

      // Date ranges label
      const dateRangesLabel = document.createElement('label');
      dateRangesLabel.htmlFor = 'date-range-label';
      dateRangesLabel.appendChild(document.createTextNode('Non working periods:'));
      dateRangesLabel.appendChild(document.createElement('br'));
      dateRangesLabel.appendChild(document.createElement('br'));

      // Date ranges container
      const dateRangesContainer = document.createElement('div');
      dateRangesContainer.id = 'date-ranges-container';

      // Initial date range row
      const createDateRangeRow = (fromDate = null, toDate = null) => {
          const row = document.createElement('div');
          row.classList.add('date-range-row');

          const fromDateInput = document.createElement('input');
          fromDateInput.type = 'date';
          fromDateInput.placeholder = 'Non-Working From';
          //fromDateInput.valueAsDate = fromDate;
          fromDateInput.value = fromDate;

          const toDateInput = document.createElement('input');
          toDateInput.type = 'date';
          toDateInput.placeholder = 'Non-Working To';
          //toDateInput.valueAsDate = toDate;
          toDateInput.value = toDate;

          row.appendChild(fromDateInput);
          row.appendChild(toDateInput);

          return row;
      };

      // Initial date ranges
      if(existingNonWorkingDatesConfig.nonWorkingPeriods.length === 0) {
        const initialDateRange = createDateRangeRow();
        dateRangesContainer.appendChild(initialDateRange);
      // Existing date ranges  
      } else {
        existingNonWorkingDatesConfig.nonWorkingPeriods
          .forEach(nonWorkingPeriod => {
            const dateRange = createDateRangeRow(nonWorkingPeriod.fromDate, nonWorkingPeriod.toDate);
            dateRangesContainer.appendChild(dateRange);
        });
      }

      // Add "+" button
      const addButton = document.createElement('button');
      addButton.textContent = '+';
      addButton.addEventListener('click', () => {
          const newDateRange = createDateRangeRow();
          dateRangesContainer.appendChild(newDateRange);
      });

      const addButtonContainer = document.createElement('div');
      addButtonContainer.style.textAlign = 'right';
      addButtonContainer.appendChild(addButton);

      popup.appendChild(dateRangesLabel);
      popup.appendChild(dateRangesContainer);
      popup.appendChild(addButtonContainer);

      // Popup controls
      const controlsSection = document.createElement('div');
      controlsSection.classList.add('popup-controls');

      // Clear button
      const clearButton = document.createElement('button');
      clearButton.textContent = 'Clear';
      clearButton.addEventListener('click', () => {
          // Reset checkboxes
          saturdayCheckbox.checked = true;
          sundayCheckbox.checked = true;

          // Remove all date ranges except the first
          while (dateRangesContainer.children.length > 1) {
              dateRangesContainer.removeChild(dateRangesContainer.lastChild);
          }

          // Clear date inputs
          const dateInputs = dateRangesContainer.querySelectorAll('input[type="date"]');
          dateInputs.forEach(input => input.value = '');
      });

      // OK button
      const okButton = document.createElement('button');
      okButton.textContent = 'OK';
      okButton.addEventListener('click', () => {
          const nonWorkingConfig = getNonWorkingDates();
          // Store in global configuration object
          window.NonWorkingDatesConfig.setConfig(nonWorkingConfig);
          document.body.removeChild(overlay);
          generateGanttChart();
          return nonWorkingConfig;
      });

      controlsSection.appendChild(clearButton);
      controlsSection.appendChild(okButton);

      popup.appendChild(controlsSection);
      overlay.appendChild(popup);
      document.body.appendChild(overlay);

      // Helper function to get non-working dates configuration
      function getNonWorkingDates() {
          // Prepare the return object
          const nonWorkingConfig = {
              saturdayNonWorking: saturdayCheckbox.checked,
              sundayNonWorking: sundayCheckbox.checked,
              nonWorkingPeriods: [],
              nonWorkingDates: []
          };
          // Add date ranges
          const dateRanges = dateRangesContainer.querySelectorAll('.date-range-row');
          let i = 0;
          dateRanges.forEach(row => {
              const fromInput = row.querySelector('input[type="date"]:first-child');
              const toInput = row.querySelector('input[type="date"]:last-child');
              nonWorkingConfig.nonWorkingPeriods[i] = {fromDate: new Date(fromInput.value), toDate: new Date(toInput.value)};
              if (fromInput.value && toInput.value)
                nonWorkingConfig.nonWorkingPeriods[i] = 
                  {fromDate: (new Date(fromInput.value)).toISOString().split('T')[0], 
                   toDate: (new Date(toInput.value)).toISOString().split('T')[0]};
              i++;
              if (fromInput.value && toInput.value) {
                  const fromDate = new Date(fromInput.value);
                  const toDate = new Date(toInput.value);
                  // Ensure from date is before or equal to to date
                  if (fromDate <= toDate) {
                      for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
                          const currentDate = new Date(d);
                          const dateString = currentDate.toISOString().split('T')[0];
                          // Check weekend conditions
                          if ((nonWorkingConfig.saturdayNonWorking && currentDate.getDay() === 6) ||
                              (nonWorkingConfig.sundayNonWorking && currentDate.getDay() === 0) ||
                              // Include other dates in the range
                              (currentDate.getDay() > 0 && currentDate.getDay() < 6)) {
                              // Avoid duplicates
                              if (!nonWorkingConfig.nonWorkingDates.includes(dateString)) {
                                  nonWorkingConfig.nonWorkingDates.push(dateString);
                              }
                          }
                      }
                  }
              }
          });
          // Sort the dates
          nonWorkingConfig.nonWorkingDates.sort();
          return nonWorkingConfig;
        }
        // Return object with method to get non-working dates
        return {getNonWorkingDates: getNonWorkingDates};
  }

  // Global function to open popup for non working dates
  function openNonWorkingDatesPopup() {
      window.nonWorkingDatesSelector = createNonWorkingDatesPopup();
  }

  async function saveProjectToFile() {
    try {
        const settings = {};

        // Get all input elements within the #options div
        const optionsDiv = document.getElementById("inputArea");
        const inputs = optionsDiv.querySelectorAll("input, select, textarea");

        // Iterate through inputs to collect their id and value
        inputs.forEach(input => {
          if (input.type === "checkbox") {
            settings[input.id] = input.checked; // Save boolean for checkboxes
          } else if (input.type === "number") {
            settings[input.id] = parseFloat(input.value); // Save number for number inputs
          } else if (input.tagName.toLowerCase() === "select") {
            settings[input.id] = input.value; // Save the selected value for select elements
          } else {
            settings[input.id] = input.value; // Save string for text, date inputs
          }
        });

        // Add non-working dates configuration
        const nonWorkingConfig = getNonWorkingDatesConfig();
        settings.nonWorkingConfig = nonWorkingConfig;

        // Convert settings to JSON
        const settingsJSON = JSON.stringify(settings, null, 2);

        // Prompt the user to select a file name and folder
        const fileHandle = await window.showSaveFilePicker({
            suggestedName: "project-settings.json",
            types: [
                {
                    description: "JSON Files",
                    accept: { "application/json": [".json"] }
                }
            ]
        });

        // Create a writable stream and write the JSON to the file
        const writableStream = await fileHandle.createWritable();
        await writableStream.write(settingsJSON);
        await writableStream.close();

        alert("Project saved successfully!");
    } catch (error) {
        console.error("Error saving settings:", error);
        alert("Failed to save project. Make sure your browser supports the File System Access API.");
    }
  }

  async function saveTasksAsCSV(inputString){
    try {
      // Prompt the user to select a file name and folder
      const fileHandle = await window.showSaveFilePicker({
      suggestedName: "project-tasks.txt.csv",
        types: [{
                 description: "CSV Files",
                 accept: { "application/csv": [".csv"] }
               }]
      });

      // Create a writable stream and write the CSV to the file
      const writableStream = await fileHandle.createWritable();
      await writableStream.write(inputString);
      await writableStream.close();
      alert("File saved successfully!");
      } catch (error) {
        console.error("Error saving CSV file:", error);
        alert("Failed to save file. Make sure your browser supports the File System Access API.");
    }
  } 


  function openProjectFromFile() {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.json'; // Only allow JSON files
    fileInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const fileContent = await file.text(); // Read file content as text
            const settings = JSON.parse(fileContent); // Parse the JSON content

            const optionsDiv = document.getElementById("inputArea");
            const inputs = optionsDiv.querySelectorAll("input, select, textarea");

            inputs.forEach(input => {
                if (settings.hasOwnProperty(input.id)) {
                    if (input.type === "checkbox") {
                        input.checked = settings[input.id]; // Load boolean for checkboxes
                    } else if (input.type === "number") {
                        input.value = parseFloat(settings[input.id]); // Load number for number inputs
                    } else if (input.tagName === "SELECT") {
                        const selectValue = settings[input.id];
                        const matchingOption = Array.from(input.options).find(option => option.value === selectValue);
                        if (matchingOption) {
                            input.value = selectValue; // Set the selected option
                        }
                    } else {
                        input.value = settings[input.id]; // Load string for text, date, and textarea
                    }
                }
            });
            // Restore nonWorkingConfig if present
            if (settings.nonWorkingConfig) {
              setNonWorkingDatesConfig(settings.nonWorkingConfig);
            }
            // Call generateGanttChart() after loading all settings
            generateGanttChart();
        } catch (error) {
            console.error("Failed to load settings:", error);
            alert("Failed to load project. Please ensure the file is valid.");
        }
    });

    // Trigger the file input dialog
    fileInput.click();
  }

  function generateGanttChart() {
    
    const csvData = document.getElementById("csvInput").value;
    const leftMargin = parseInt(document.getElementById("leftMargin").value);
    const verticalShift = parseInt(document.getElementById("verticalShift").value);
    const offsetZeroX = parseInt(document.getElementById("offsetZeroX").value);
    const chartWidth = parseInt(document.getElementById("chartWidth").value);
    const rightMargin = parseInt(document.getElementById("rightMargin").value);
    const barHeight = parseInt(document.getElementById("barHeight").value);
    const barSpace = parseInt(document.getElementById("barSpace").value);
    const percentCompleteColor = document.getElementById("percentCompleteColor").value;
    const percentNotCompleteColor = document.getElementById("percentNotCompleteColor").value;
    const strokeColor = document.getElementById("strokeColor").value;
    const barBorderThickness = document.getElementById("barBorderThickness").value;
    const barAngles = document.getElementById("barAngles").value;

    const verticalLinesColor = document.getElementById("verticalLinesColor").value;
    const horizontalSeparatorsColor = document.getElementById("horizontalSeparatorsColor").value;
    
    const tasksCharSize = parseInt(document.getElementById("tasksCharSize").value);
    const tasksCharFamily = document.getElementById("tasksCharFamily").value;
    const tasksCharStyle = document.getElementById("tasksCharStyle").value;
    const tasksCharWeight = document.getElementById("tasksCharWeight").value;
    const tasksCharColor = document.getElementById("tasksCharColor").value;
    const tasksTruncate = parseInt(document.getElementById("tasksTruncate").value);
    const tasksDetailedInfo_0 = (document.getElementById("tasksDetailedInfo_0")).checked;
    const tasksDetailedInfo_1 = (document.getElementById("tasksDetailedInfo_1")).checked;
    const tasksDetailedInfo_2 = (document.getElementById("tasksDetailedInfo_2")).checked;    
    const datesCharSize = parseInt(document.getElementById("datesCharSize").value);
    const datesCharFamily = document.getElementById("datesCharFamily").value;
    const datesFormat = document.getElementById("datesFormat").value;
    const datesCharStyle = document.getElementById("datesCharStyle").value;
    const datesCharWeight = document.getElementById("datesCharWeight").value;
    const datesCharColor = document.getElementById("datesCharColor").value;
    const delayedColor = document.getElementById("delayedColor").value;
    
    const dependenciesLineColor = document.getElementById("dependenciesLineColor").value;
    const dependenciesLineDashed = document.getElementById("dependenciesLineDashed").value;
    const criticalPathLineColor = document.getElementById("criticalPathLineColor").value;
    const criticalPathLineWidth = document.getElementById("criticalPathLineWidth").value;
    const timelineY = parseInt(document.getElementById("timelineY").value);
    const offsetDateBarV = parseInt(document.getElementById("offsetDateBarV").value);
    const offsetDateBarLeftH = parseInt(document.getElementById("offsetDateBarLeftH").value);
    const offsetDateBarRightH = parseInt(document.getElementById("offsetDateBarRightH").value);
    const headerSpaceFromTimelineY = parseInt(document.getElementById("headerSpaceFromTimelineY").value);
    const headerDatesSpace = parseInt(document.getElementById("headerDatesSpace").value);

    const percentCompleteMultiplier = (document.getElementById("percentCompleteMultiplier")).checked;
    const projectStartDate = (document.getElementById("projectStartDate")).value;
    const todayDate = (document.getElementById("todayDate")).value;

    const tasks = parseCSV(csvData, percentCompleteMultiplier, projectStartDate, todayDate);
    const { minDate, maxDate, uniqueStartDates } = calculateTimeline(tasks);
    
    createGanttChart(tasks, minDate, maxDate, uniqueStartDates, {
      leftMargin,
      verticalShift,
      offsetZeroX,
      chartWidth,
      rightMargin,
      barHeight,
      barSpace,
      percentCompleteColor,
      percentNotCompleteColor,
      strokeColor,
      barBorderThickness,
      barAngles,
      verticalLinesColor,
      horizontalSeparatorsColor,
      tasksCharSize,
      tasksCharFamily,
      tasksCharStyle,
      tasksCharWeight,
      tasksCharColor,
      tasksTruncate,
      tasksDetailedInfo_0,
      tasksDetailedInfo_1,
      tasksDetailedInfo_2,
      datesCharSize,
      datesCharFamily,
      datesFormat,
      datesCharStyle,
      datesCharWeight,
      datesCharColor,
      dependenciesLineColor,
      dependenciesLineDashed,
      criticalPathLineColor,
      criticalPathLineWidth,
      delayedColor,
      timelineY,
      offsetDateBarV,
      offsetDateBarLeftH,
      offsetDateBarRightH,
      headerSpaceFromTimelineY,
      headerDatesSpace
    });
  }
</script>

</body>
</html>
