<!DOCTYPE html>

<!-- Title: Easy Gantt 
     Author: Giampaolo Marucci
     Version: 2.0.2
     Date: 30 Dec 2025 -->

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    #layoutWrapper {
      transform-origin: top left;
      width: fit-content;
      height: fit-content;
    }
    /* Styling for input text area */
    #ganttChart {
      border: 1px solid #ccc;
    }
    #title {
      text-align: center;
      font-size: 14px;
      font-weight: bold;
      margin-top: 5px;
    }
    #inputArea {
      margin: 10px;
      display: flex; 
      align-items: flex-start;
      font-size: 12px;
    }
    #inputArea textarea {
      font-size: 10px; 
    }
    #inputArea button {
      font-size: 10px;
    }
    #inputArea input[type="date"] {
      width: 95px;
      height: 12px;
      font-size: 11px; 
    }
    #inputArea input[type="checkbox"] {
      width: auto;
    }
    #tasksSelector {
      display: flex; 
      flex-direction: column;
      font-size: 12px;
      position: relative;
      padding: 0px 10px;
      margin-right: 0px;
      margin-top:7px;
    }
    #tasksSelector select {
      font-size: 10px; 
      margin-top: 7px;
      width: 72px;
      height: 72px;
    }
    /* Styling for the tab buttons */
    .tab-container {
        display: flex;
        flex-direction: column;
    }
    .tab {
        display: flex;
        cursor: pointer;
    }
    .tab div {
        padding: 5px 10px;
        border: 0px solid #ccc;
        margin-right: 10px;
        background-color: #f1f1f1;
    }
    .tab div.active {
        background-color: #ddd;
        border: 1px solid #ccc;
    }
    /* Styling for tab content */
    .tab-content-container {
        margin-top: 2px;
        position: relative;
        width: 800px;
    }
    .tab-content {
        display: none;
        padding: 10px;
        border: 1px solid #ccc;
        position: relative;
        width: 100%;       
        box-sizing: border-box;
    }
    .tab-content.active {
        display: block;
        position: relative;
    }
    /* Styles for input controls */
    #options {
      flex-direction: column;
    }
    #options label {
      margin-left: 16px;
      font-size: 10px;
    }
    #options input[type="number"]{
      width: 40px;
      font-size: 10px; 
      padding: 1px;
    }
    #options select,
    #options input[type="date"] {
      width: 70px;
      font-size: 10px; 
      padding: 1px;
    }
    #options input[type="checkbox"] {
      width: auto; 
    }
    /* Styles for the Non-Working Dates popup */
    .popup-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    .popup-container {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        width: 400px;
        max-width: 90%;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .date-range-row {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }
    .date-range-row input {
        flex-grow: 1;
        margin-right: 10px;
    }
    .popup-controls {
        display: flex;
        justify-content: space-between;
        margin-top: 20px;
    }
    .checkbox-section {
        margin-bottom: 15px;
    }
    
  </style>
</head>

<body onload="generateGanttChart()">

<div id="layoutWrapper">
<div id="htmlScaleWrapper">
<div id="title">Easy Gantt - by Giampaolo Marucci</div>
<div id="inputArea">
  <div id="inputText">
    <label for="csvInput" title="Input field for tasks data"><b>Comma or tab separated values for each Task/Line:</b></label><br>
    <label for="csvInput" style="font-size:9px;" title="Input field for tasks data"><i>Id, Name, Duration, Percent complete, Predecessors, is Parent (optional), Parent id</i></label>   
    <br>
    <textarea id="csvInput" rows="4" cols="53" onchange="generateGanttChart(event)">
1,Task 1.1,5 days,100.00%,,
2,Task 1.2,8 days,90,1FS-1 day,
3,Task 1.3,4 days,0.00%,,
4,Task 1.3.1,5,10,2FF+1,3
5,Milestone 1,0 days,0.00%,4;2;1,3
6,Task 2.1,3 days,100,1SS,3
7,Task 2.2,7 days,100,6
8,Task 2.3,6 days,0.00%,7FS+3 days
9,Task 2.4,12 days,0.00%,
10,Task 2.4.1, 20, 40,7,9
11,Milestone 2,0 days,0.00%,5;10
12,Milestone 3,0 days,0.00%,11
    </textarea><br>
    
    <button id="openProjectFromFile" title="Open a Gantt chart and its Settings from a JSON file type" onclick="openProjectFromFile(event)">Open JSON</button>
    <button id="saveProjectToFile" title="Save the Gantt chart and Settings in a JSON file type" onclick="saveProjectToFile()">Save as JSON</button>
    <button id="exportSVGButton" title="Save the Gantt chart as SVG - Scalable Vector Graphics - file" onclick="exportGanttChartAsSVG()">Save as SVG</button>
    <button id="saveAsCSV" title="Save the tasks in a CSV file type" 
           onclick='saveTasksAsCSV((toCSV(parseCSV(document.getElementById("csvInput").value, 
                                                   document.getElementById("percentCompleteMultiplier").checked, 
                                                   document.getElementById("projectStartDate").value, 
                                                   document.getElementById("todayDate").value),
                                           document.getElementById("datesFormat").value
                                         )
                                   ))'
           >Save as CSV</button>

    <!-- UNCOMMENT TO USE EDIT MODE -->
    <!--</br><label for="editMode" title="Edit mode">Edit Mode</label>
    <input type="checkbox" id="editMode" onchange="generateGanttChart(event)">-->

  </div> <!-- End <div id="inputText"> -->

  <div id="tasksSelector"></div>

  <div class="tab-container">
  <div class="tab">
    <div class="tab-button active" onclick="openTab(event, 'tab1')">Project</div>
    <div class="tab-button" onclick="openTab(event, 'tab2')">Header</div>
    <div class="tab-button" onclick="openTab(event, 'tab3')">Chart</div>
    <div class="tab-button" onclick="openTab(event, 'tab4')">Bars</div>
    <div class="tab-button" onclick="openTab(event, 'tab5')">Tasks</div>
    <div class="tab-button" onclick="openTab(event, 'tab6')">Parents</div>
    <div class="tab-button" onclick="openTab(event, 'tab7')">Delay</div>    
    <div class="tab-button" onclick="openTab(event, 'tab8')">Dates</div>
    <div class="tab-button" onclick="openTab(event, 'tab9')">Filters</div>
  </div> <!-- End <div class="tab"> -->

  <div class="tab-content-container">
  <div id="tab1" class="tab-content active">
  <div id="options">
    <!--Project Settings-->

    <!-- Calendar Settings -->
    <button id="nonWorkingDates" title="Set Non-Working dates for the project" onclick="openNonWorkingDatesPopup()">Calendar</button>
    
    <!-- Project Start Date -->
    <label for="projectStartDate" title="Start date">Project Start Date:</label>
    <input type="date" id="projectStartDate" value="" onload="this.value = todayDateMinusOneMonth();" onchange="generateGanttChart(event)"/>

    <!-- Today Date -->
    <label for="todayDate" title="Today's date">Today Date:</label>
    <input type="date" id="todayDate" value="" onload="this.value = todayDate();" onchange="generateGanttChart(event)" />

    <!-- Percent Complete * 100 -->
    <label for="percentCompleteMultiplier" title="Multiply Percent Complete by 100">Percent Complete *100:</label>
    <input type="checkbox" id="percentCompleteMultiplier" onclick="generateGanttChart(event)" />

  </div> <!-- End <div id="options"> -->
  </div> <!-- End <div id="tab1" class="tab-content active"> -->

  <div id="tab2" class="tab-content">
  <div id="options">
    <!-- Header Dates Settings -->    

    <!-- Header Dates format -->    
    <label for="headerDatesFormat" title="Format of dates labels text in the header line"`>Format:</label>
    <select id="headerDatesFormat" onclick="generateGanttChart(event)">
      <option value="MM/DD/YYYY">MM/DD/YYYY</option>
      <option value="DD/MM/YYYY">DD/MM/YYYY</option>
      <option value="YYYY-MM-DD">YYYY-MM-DD</option>
      <option value="MMM DD, YYYY">MMM DD, YYYY</option>
      <option value="DD MMM YYYY" selected>DD MMM YYYY</option>
    </select>

    <!-- Header Dates char size -->
    <label for="headerDatesCharSize" title="Size of dates labels text, in pixels in the header line">Size:</label>
    <input type="number" id="headerDatesCharSize" value="12" onchange="generateGanttChart(event)"/>
    
    <!-- Header Dates char family -->
    <label for="headerDatesCharFamily" title="Font family of dates labels text in the header line">Family:</label>
    <select id="headerDatesCharFamily" onclick="generateGanttChart(event)">
        <option value="Arial">Arial</option>
        <option value="Verdana">Verdana</option>
        <option value="Helvetica" selected>Helvetica</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Georgia">Georgia</option>
        <option value="Courier New">Courier New</option>
        <option value="Tahoma">Tahoma</option>
        <option value="Trebuchet MS">Trebuchet MS</option>
        <option value="Impact">Impact</option>
        <option value="Comic Sans MS">Comic Sans MS</option>
        <option value="Lucida Sans">Lucida Sans</option>
        <option value="Calibri">Calibri</option>
        <option value="Garamond">Garamond</option>
        <option value="Cambria">Cambria</option>
        <option value="Palatino">Palatino</option>
        <option value="Roboto">Roboto</option>
        <option value="Open Sans">Open Sans</option>
        <option value="Lato">Lato</option>
        <option value="Montserrat">Montserrat</option>
        <option value="Raleway">Raleway</option>
    </select>

    <!-- Header Dates Char Style -->
    <label for="headerDatesCharStyle" title="Style of dates labels text in the header line">Style:</label>
    <select id="headerDatesCharStyle" onclick="generateGanttChart(event)">
      <option value="normal" selected>Normal</option>
      <option value="italic">Italic</option>
      <option value="oblique">Oblique</option>
    </select>

    <!-- Header Dates Char Weight -->
    <label for="headerDatesCharWeight" title="Weight of dates labels text in the header line">Weight:</label>
    <select id="headerDatesCharWeight" onclick="generateGanttChart(event)">
      <option value="normal" selected>Normal</option>
      <option value="bold">Bold</option>
      <option value="lighter">Lighter</option>
      <option value="bolder">Bolder</option>
    </select>

    <!-- Header Dates Char Color -->
    <label for="headerDatesCharColor" title="Color of dates labels text in the header line, 'None' is no dates showed">Color:</label>
    <select id="headerDatesCharColor" onclick="generateGanttChart(event)">
      <option value="none" selected>None</option>
      <option value="black" selected>Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

    <!-- Header Vertical Space -->
    <label for="headerSpaceFromTimelineY" title="Vertical spacing of header from the timeline, in pixels">Vert Space:</label>
    <input type="number" id="headerSpaceFromTimelineY" value="8" onchange="generateGanttChart(event)"/>

    <!-- Header Dates Space -->
    <label for="headerDatesSpace" title="Horizontal spacing of dates in header, in pixels. Increasing the value some dates disappear">Dates Distance:</label>
    <input type="number" id="headerDatesSpace" value="65" onchange="generateGanttChart(event)"/>

  </div> <!-- End <div id="options"> -->
  </div> <!-- End <div id="tab2" class="tab-content"> -->
  
  <div id="tab3" class="tab-content">
  <div id="options">
    <!-- Chart Settings -->

    <!-- Chart Width -->
    <label for="chartWidth" title="Width in pixels of the whole chart">Chart Width:</label>
    <input type="number" id="chartWidth" value="800" onchange="generateGanttChart(event)"/>
      
    <!-- Left Margin Control -->
    <label for="leftMargin" title="Distance of left margin of the whole chart form the left of the page, in pixels">Left Margin:</label>
    <input type="number" id="leftMargin" value="4" onchange="generateGanttChart(event)"/>

    <!-- Vertical axe 0 -->
    <label for="verticalShift" title="Zero position of the vertical axe of the Gantt chart from the left of the page, in pixels">Y Zero :</label>
    <input type="number" id="verticalShift" value="232" onchange="generateGanttChart(event)"/>

    <!-- Horizontal axe 0 -->
    <label for="timelineY" title="Zero position of the horizontal axe of the Gantt chart from the top of the page, in pixels">X Zero:</label>
    <input type="number" id="timelineY" value="60" onchange="generateGanttChart(event)"/>

    <!-- Offset Zero Start Date Control -->
    <label for="offsetZeroX" title="Distance of the bars from the vertical axe in the Gantt chart, in pixels">Start Date Zero:</label>
    <input type="number" id="offsetZeroX" value="84" onchange="generateGanttChart(event)"/>

    <!-- Right Margin -->
    <label for="rightMargin" title="Space between the right margin of the whole chart and the right of the page, in pixels">Right Margin:</label>
    <input type="number" id="rightMargin" value="120" onchange="generateGanttChart(event)"/>

    <!-- Axes Lines Width -->
    <label for="axesWidth" title="Axes lines width, in pixels">Axes Width:</label>
    <input type="number" id="axesWidth" value="2" onchange="generateGanttChart(event)"/>

    <!-- Axes Color -->
    <label for="axesColor" title="Color of axe lines, 'None' is no axes">Axes:</label>
    <select id="axesColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="black" selected>Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="#ccc">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

    <!-- Vertical lines Width -->
    <label for="verticalLinesWidth" title="Width of the vertical timelines, in pixels">Timelines Width:</label>
    <input type="number" id="verticalLinesWidth" value="1" onchange="generateGanttChart(event)"/>

    <!-- Vertical Lines Color -->
    <label for="verticalLinesColor" title="Color of vertical timelines, 'None' is no vertical lines">Timelines:</label>
    <select id="verticalLinesColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="black">Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="#ccc" selected>Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

    <!-- Today Date Line Color -->
    <label for="todayDateLineColor" title="Color of Today date line, 'None' is no Today date line showed, Today line is not showed if out of dates range in Gnatt chart">Today Line:</label>
    <select id="todayDateLineColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="black">Black</option>
      <option value="orange">Orange</option>
      <option value="red" selected>Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="#ccc" >Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

    <!-- Today Line Width -->
    <label for="todayDateLineWidth" title="Width of Today line, in pixels, Today line is not showed if out of dates range in Gnatt chart">Today Width:</label>
    <input type="number" id="todayDateLineWidth" value="2" onchange="generateGanttChart(event)"/>

    <!-- Today Dashed Line -->
    <label for="todayDateLineDashed" title="Style of Today line, applicable only if 'Today line' in not 'None'">Today Dashed:</label>
    <select id="todayDateLineDashed" onclick="generateGanttChart(event)">
      <option value="0,0">Not Dashed</option>
      <option value="4,4" selected>Dashed</option>
    </select>

  </div> <!-- End <div id="options"> -->
  </div> <!-- End <div id="tab3" class="tab-content"> -->

  <div id="tab4" class="tab-content">
  <div id="options">
  
    <!--Bars Settings-->

    <!-- Bars Height -->
    <label for="barHeight" title="Height of the bars in the Gantt chart, in pixels">Height:</label>
    <input type="number" id="barHeight" value="16" onchange="generateGanttChart(event)"/>

    <!-- Bars Distance -->
    <label for="barSpace" title="Space between bars in the Gantt chart, in pixels">Space:</label>
    <input type="number" id="barSpace" value="16" onchange="generateGanttChart(event)"/>

    <!-- Color for Percent Not Complete Bars -->
    <label for="percentNotCompleteColor" title="Color of the not complete portion of the bars, 'None' is no bar showed">% Not Complete:</label>
    <select id="percentNotCompleteColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
      <option value="orange" selected>Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="black">black</option>
    </select>

    <!-- Color for Percent Complete Bars --> 
    <label for="percentCompleteColor" title="Color of the complete portion of the bars,'None' is no bar showed">% Complete:</label>
    <select id="percentCompleteColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="green" selected>Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="black">black</option>
    </select>

    <!-- Color for Border of Bars -->
    <label for="strokeColor" title="Color of the bars borders, 'None' is no border showed">Border:</label>
    <select id="strokeColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="black" selected>Black</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
    </select>

    <!-- Bars border thickness -->
    <label for="barBorderThickness" title="Thickness in pixels of bars borders, only applicable if 'Bars border' color not 'None'">Border Thickness:</label>
    <input type="number" id="barBorderThickness" value="1" onchange="generateGanttChart(event)"/>

    <!-- Bars angles -->
    <label for="barAngles" title="Angle size of the bars corners, 0 is 90 degrees angle applied">Angles:</label>
    <input type="number" id="barAngles" value="0" onchange="generateGanttChart(event)"/>

    <!-- Critical Path Line Color -->
    <label for="criticalPathLineColor" title="Color of the critical bars section within the critical bars, 'None' is no critial section is showed within the bars">Critical:</label>
    <select id="criticalPathLineColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="black">Black</option>
      <option value="orange">Orange</option>
      <option value="red" selected>Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

    <!-- Critical Path Line Width -->
    <label for="criticalPathLineWidth" title="Width of the critical section within the critical bars of the critical path, only applicable if 'Critical' is not 'None'">Critical Width:</label>
    <input type="number" id="criticalPathLineWidth" value="2" onchange="generateGanttChart(event)"/>

    <!-- Dependecies Line Color -->
    <label for="dependenciesLineColor" title="Color of dependency lines, 'None' is no dependency lines showed">Dependencies:</label>
    <select id="dependenciesLineColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="black">Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal" selected>Teal</option>
      <option value="pink">Pink</option>
    </select>

    <!-- Dependencies Line Width -->
    <label for="dependenciesLineWidth" title="Width of the dependencies lines, only applicable if 'Dependencies' is not 'none'">Dependencies Width:</label>
    <input type="number" id="dependenciesLineWidth" value="1" onchange="generateGanttChart(event)"/>

    <!-- Dependecies Dashed Line -->
    <label for="dependenciesLineDashed" title="Style of dependency lines, applicable only if 'Dependencies' in not 'None'">Dependencies Dashed:</label>
    <select id="dependenciesLineDashed" onclick="generateGanttChart(event)">
      <option value="0,0" selected>Not Dashed</option>
      <option value="4,4">Dashed</option>
    </select>

  </div> <!-- End <div id="options"> -->
  </div> <!-- End <div id="tab4" class="tab-content"> -->

  <div id="tab5" class="tab-content">
  <div id="options">
    <!-- Tasks Settings -->

    <!-- Tasks char size -->
    <label for="tasksCharSize" title="Size of task labels text, in pixels">Size:</label>
    <input type="number" id="tasksCharSize" value="12" onchange="generateGanttChart(event)"/>

    <!-- Tasks char family -->
    <label for="tasksCharFamily" title="Font family of tasks labels text">Family:</label>
    <select id="tasksCharFamily" onclick="generateGanttChart(event)">
        <option value="Arial">Arial</option>
        <option value="Verdana">Verdana</option>
        <option value="Helvetica" selected>Helvetica</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Georgia">Georgia</option>
        <option value="Courier New">Courier New</option>
        <option value="Tahoma">Tahoma</option>
        <option value="Trebuchet MS">Trebuchet MS</option>
        <option value="Impact">Impact</option>
        <option value="Comic Sans MS">Comic Sans MS</option>
        <option value="Lucida Sans">Lucida Sans</option>
        <option value="Calibri">Calibri</option>
        <option value="Garamond">Garamond</option>
        <option value="Cambria">Cambria</option>
        <option value="Palatino">Palatino</option>
        <option value="Roboto">Roboto</option>
        <option value="Open Sans">Open Sans</option>
        <option value="Lato">Lato</option>
        <option value="Montserrat">Montserrat</option>
        <option value="Raleway">Raleway</option>
    </select>

    <!-- Tasks Char Style -->
    <label for="tasksCharStyle" title="Style of tasks labels text">Style:</label>
    <select id="tasksCharStyle" onclick="generateGanttChart(event)">
      <option value="normal" selected>Normal</option>
      <option value="italic">Italic</option>
      <option value="oblique">Oblique</option>
    </select>

    <!-- Tasks Char Weight -->
    <label for="tasksCharWeight" title="Weight of the tasks labels text">Weight:</label>
    <select id="tasksCharWeight" onclick="generateGanttChart(event)">
      <option value="normal" selected>Normal</option>
      <option value="bold">Bold</option>
      <option value="lighter">Lighter</option>
      <option value="bolder">Bolder</option>
    </select>

    <!-- Tasks Char Color -->
    <label for="tasksCharColor" title="Color of tasks labels text, 'None' is no tasks label showed. Combined with the 'Tasks Delay' color">Color:</label>
    <select id="tasksCharColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="black" selected>Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

    <!-- Text Horiz Align -->
    <label for="offsetTextTaskH" title="Indentation, that is horizontal alignement position of tasks text against the left margin positioning, in pixels">X Align:</label>
    <input type="number" id="offsetTextTaskH" value="22" onchange="generateGanttChart(event)"/>

    <!-- Text Vert Align -->
    <label for="offsetDateBarV" title="Vertical alignement position of tasks and dates labels against the bars center positioning, in pixels">Y Align:</label>
    <input type="number" id="offsetDateBarV" value="10" onchange="generateGanttChart(event)"/>

    <!-- Tasks truncate chars -->
    <label for="tasksTruncate" title="Number of characters to truncate the task names">Trunc:</label>
    <input type="number" id="tasksTruncate" value="35" onchange="generateGanttChart(event)"/>

    <!-- Horizontal Separators Lines Color -->
    <label for="horizontalSeparatorsColor" title="Color of lines separating the bars horizontally, 'None' is no separator lines showed">Separators:</label>
    <select id="horizontalSeparatorsColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="black">Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="#ccc" selected>Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

    <!-- Horizontal Separators Lines Width -->
    <label for="horizontalSeparatorsWidth" title="Width of lines separating the bars horizontally, in pixels">Separators width:</label>
    <input type="number" id="horizontalSeparatorsWidth" value="1" onchange="generateGanttChart(event)"/>

    <!-- Show detailed tasks info line 0-->
    <label for="tasksDetailedInfo_0" title="Show detailed additional task information">Actuals:</label>
    <input type="checkbox" id="tasksDetailedInfo_0" onclick="generateGanttChart(event)" />

    <!-- Show detailed tasks info line 1-->
    <label for="tasksDetailedInfo_1" title="Show detailed additional task information">Durations:</label>
    <input type="checkbox" id="tasksDetailedInfo_1" onclick="generateGanttChart(event)" />

    <!-- Show detailed tasks info line 2-->
    <label for="tasksDetailedInfo_2" title="Show detailed additional task information">Predecessors:</label>
    <input type="checkbox" id="tasksDetailedInfo_2" onclick="generateGanttChart(event)" />

  </div> <!-- End <div id="options"> -->
  </div> <!-- End <div id="tab5" class="tab-content"> -->

  <div id="tab6" class="tab-content">
  <div id="options">
    <!-- Parent Settings -->

    <!-- Color for Percent Not Complete Parent Bars -->
    <label for="parentPercentNotCompleteColor" title="Color of the not complete portion of the parent bars, 'None' is no bar showed">% Not Complete:</label>
    <select id="parentPercentNotCompleteColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal" selected>Teal</option>
      <option value="pink">Pink</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="black">black</option>
    </select>

    <!-- Color for Percent Complete Parent Bars --> 
    <label for="parentPercentCompleteColor" title="Color of the complete portion of the parent bars,'None' is no bar showed">% Complete:</label>
    <select id="parentPercentCompleteColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink" selected>Pink</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="black">black</option>
    </select>

    <!-- Parent Bars angles -->
    <label for="parentBarAngles" title="Angle size of the parent bars corners, 0 is 90 degrees angle applied">Bar Angles:</label>
    <input type="number" id="parentBarAngles" value="6" onchange="generateGanttChart(event)"/>    

    <!-- Parent char size -->
    <label for="parentsCharSize" title="Size of parent task labels text, in pixels">Char Size:</label>
    <input type="number" id="parentsCharSize" value="12" onchange="generateGanttChart(event)"/>

    <!-- Parents char family -->
    <label for="parentsCharFamily" title="Font family of parent tasks labels text">Char Family:</label>
    <select id="parentsCharFamily" onclick="generateGanttChart(event)">
        <option value="Arial">Arial</option>
        <option value="Verdana">Verdana</option>
        <option value="Helvetica" selected>Helvetica</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Georgia">Georgia</option>
        <option value="Courier New">Courier New</option>
        <option value="Tahoma">Tahoma</option>
        <option value="Trebuchet MS">Trebuchet MS</option>
        <option value="Impact">Impact</option>
        <option value="Comic Sans MS">Comic Sans MS</option>
        <option value="Lucida Sans">Lucida Sans</option>
        <option value="Calibri">Calibri</option>
        <option value="Garamond">Garamond</option>
        <option value="Cambria">Cambria</option>
        <option value="Palatino">Palatino</option>
        <option value="Roboto">Roboto</option>
        <option value="Open Sans">Open Sans</option>
        <option value="Lato">Lato</option>
        <option value="Montserrat">Montserrat</option>
        <option value="Raleway">Raleway</option>
    </select>

    <!-- Parents Char Style -->
    <label for="parentsCharStyle" title="Style of parent tasks labels text">Char Style:</label>
    <select id="parentsCharStyle" onclick="generateGanttChart(event)">
      <option value="normal" selected>Normal</option>
      <option value="italic">Italic</option>
      <option value="oblique">Oblique</option>
    </select>

    <!-- Parents Char Weight -->
    <label for="parentsCharWeight" title="Weight of the parent tasks labels text">Char Weight:</label>
    <select id="parentsCharWeight" onclick="generateGanttChart(event)">
      <option value="normal">Normal</option>
      <option value="bold" selected>Bold</option>
      <option value="lighter">Lighter</option>
      <option value="bolder">Bolder</option>
    </select>

    <!-- Parents Char Color -->
    <label for="parentsCharColor" title="Color of parent tasks labels text, 'None' is no tasks label showed. Combined with the 'Tasks Delay' color">Char Color:</label>
    <select id="parentsCharColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="black" selected>Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

  </div> <!-- End <div id="options"> -->
  </div> <!-- End <div id="tab6" class="tab-content"> -->

  <div id="tab7" class="tab-content">
  <div id="options">
    <!-- Delay Tasks Settings -->

    <!-- Delay char size -->
    <label for="delayCharSize" title="Size of delay task labels text, in pixels">Size:</label>
    <input type="number" id="delayCharSize" value="12" onchange="generateGanttChart(event)"/>

    <!-- Delay char family -->
    <label for="delayCharFamily" title="Font family of delay tasks labels text">Family:</label>
    <select id="delayCharFamily" onclick="generateGanttChart(event)">
        <option value="Arial">Arial</option>
        <option value="Verdana">Verdana</option>
        <option value="Helvetica" selected>Helvetica</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Georgia">Georgia</option>
        <option value="Courier New">Courier New</option>
        <option value="Tahoma">Tahoma</option>
        <option value="Trebuchet MS">Trebuchet MS</option>
        <option value="Impact">Impact</option>
        <option value="Comic Sans MS">Comic Sans MS</option>
        <option value="Lucida Sans">Lucida Sans</option>
        <option value="Calibri">Calibri</option>
        <option value="Garamond">Garamond</option>
        <option value="Cambria">Cambria</option>
        <option value="Palatino">Palatino</option>
        <option value="Roboto">Roboto</option>
        <option value="Open Sans">Open Sans</option>
        <option value="Lato">Lato</option>
        <option value="Montserrat">Montserrat</option>
        <option value="Raleway">Raleway</option>
    </select>

    <!-- Delay Char Style -->
    <label for="delayCharStyle" title="Style of delay tasks labels text">Style:</label>
    <select id="delayCharStyle" onclick="generateGanttChart(event)">
      <option value="normal" selected>Normal</option>
      <option value="italic">Italic</option>
      <option value="oblique">Oblique</option>
    </select>

    <!-- Delay Char Color -->
    <label for="delayCharColor" title="Color of delay tasks labels text, 'None' is no tasks label showed. Combined with the 'Tasks Delay' color">Color:</label>
    <select id="delayCharColor" onclick="generateGanttChart(event)">
      <option value="none">None</option>
      <option value="black">Black</option>
      <option value="orange">Orange</option>
      <option value="red" selected>Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>

  </div> <!-- End <div id="options"> -->
  </div> <!-- End <div id="tab7" class="tab-content"> -->

  <div id="tab8" class="tab-content">
  <div id="options">
    <!-- Dates Settings -->

    <!-- Dates format -->    
    <label for="datesFormat" title="Format of dates labels text"`>Format:</label>
    <select id="datesFormat" onclick="generateGanttChart(event)">
      <option value="MM/DD/YYYY">MM/DD/YYYY</option>
      <option value="DD/MM/YYYY">DD/MM/YYYY</option>
      <option value="YYYY-MM-DD">YYYY-MM-DD</option>
      <option value="MMM DD, YYYY">MMM DD, YYYY</option>
      <option value="DD MMM YYYY" selected>DD MMM YYYY</option>
    </select>

    <!-- Dates char size -->
    <label for="datesCharSize" title="Size of dates labels text, in pixels">Size:</label>
    <input type="number" id="datesCharSize" value="12" onchange="generateGanttChart(event)"/>
    
    <!-- Dates char family -->
    <label for="datesCharFamily" title="Font family of dates labels text">Family:</label>
    <select id="datesCharFamily" onclick="generateGanttChart(event)">
        <option value="Arial">Arial</option>
        <option value="Verdana">Verdana</option>
        <option value="Helvetica" selected>Helvetica</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Georgia">Georgia</option>
        <option value="Courier New">Courier New</option>
        <option value="Tahoma">Tahoma</option>
        <option value="Trebuchet MS">Trebuchet MS</option>
        <option value="Impact">Impact</option>
        <option value="Comic Sans MS">Comic Sans MS</option>
        <option value="Lucida Sans">Lucida Sans</option>
        <option value="Calibri">Calibri</option>
        <option value="Garamond">Garamond</option>
        <option value="Cambria">Cambria</option>
        <option value="Palatino">Palatino</option>
        <option value="Roboto">Roboto</option>
        <option value="Open Sans">Open Sans</option>
        <option value="Lato">Lato</option>
        <option value="Montserrat">Montserrat</option>
        <option value="Raleway">Raleway</option>
    </select>

    <!-- Dates Char Style -->
    <label for="datesCharStyle" title="Style of dates labels text">Style:</label>
    <select id="datesCharStyle" onclick="generateGanttChart(event)">
      <option value="normal" selected>Normal</option>
      <option value="italic">Italic</option>
      <option value="oblique">Oblique</option>
    </select>

    <!-- Dates Char Weight -->
    <label for="datesCharWeight" title="Weight of dates labels text">Weight:</label>
    <select id="datesCharWeight" onclick="generateGanttChart(event)">
      <option value="normal" selected>Normal</option>
      <option value="bold">Bold</option>
      <option value="lighter">Lighter</option>
      <option value="bolder">Bolder</option>
    </select>

    <!-- Dates Char Color -->
    <label for="datesCharColor" title="Color of dates labels text, 'None' is no dates showed">Color:</label>
    <select id="datesCharColor" onclick="generateGanttChart(event)">
      <option value="none" selected>None</option>
      <option value="black" selected>Black</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="brown">Brown</option>
      <option value="gray">Gray</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="pink">Pink</option>
    </select>
    
    <!-- Dates Left Space -->
    <label for="offsetDateBarLeftH" title="Horizontal spacing of the dates labels from left of bars, in pixels">Left Space:</label>
    <input type="number" id="offsetDateBarLeftH" value="74" onchange="generateGanttChart(event)"/>

    <!-- Dates Right Space -->
    <label for="offsetDateBarRightH" title="Horizontal spacing of the dates labels from right of bars, in pixels">Right Space:</label>
    <input type="number" id="offsetDateBarRightH" value="5" onchange="generateGanttChart(event)"/>

  </div> <!-- End <div id="options"> -->
  </div> <!-- End <div id="tab8" class="tab-content"> -->

  <div id="tab9" class="tab-content">
  <div id="options">
    <!-- Filters Settings -->

    <!-- Show Not Parent tasks and bars-->
    <label for="showOnlyNotParents" title="Show Not Parent tasks and bars, in combination with 'Show Parents'">Not Parents:</label>
    <input type="checkbox" id="showOnlyNotParents" onclick="generateGanttChart(event)" />

    <!-- Show Parent tasks and bars-->
    <label for="showOnlyParents" title="Show Parent tasks and bars, in combination with 'Show Not Parents'">Parents:</label>
    <input type="checkbox" id="showOnlyParents" onclick="generateGanttChart(event)" />

    <!-- Show Not Delay tasks and bars-->
    <label for="showOnlyNotDelay" title="Show Not Delay tasks and bars">Not Delays:</label>
    <input type="checkbox" id="showOnlyNotDelay" onclick="generateGanttChart(event)" />

    <!-- Show Delay tasks and bars-->
    <label for="showOnlyDelay" title="Show Delay tasks and bars">Delays:</label>
    <input type="checkbox" id="showOnlyDelay" onclick="generateGanttChart(event)" />

    <!-- Show Not Critical tasks and bars-->
    <label for="showOnlyNotCritical" title="Show Not Critical tasks and bars">Not Criticals:</label>
    <input type="checkbox" id="showOnlyNotCritical" onclick="generateGanttChart(event)" />

    <!-- Show Critical tasks and bars-->
    <label for="showOnlyCritical" title="Show Critical tasks and bars">Criticals:</label>
    <input type="checkbox" id="showOnlyCritical" onclick="generateGanttChart(event)" />

    <!-- Show Not Milestones-->
    <label for="showOnlyNotMilestone" title="Show Not Milestones">Not Milestones:</label>
    <input type="checkbox" id="showOnlyNotMilestone" onclick="generateGanttChart(event)" />

    <!-- Show Milestones-->
    <label for="showOnlyMilestone" title="Show Milestones">Milestones:</label>
    <input type="checkbox" id="showOnlyMilestone" onclick="generateGanttChart(event)" />

    <!-- Show Not Selected-->
    <label for="showOnlyNotSelected" title="Show Not Selected">Not Selected:</label>
    <input type="checkbox" id="showOnlyNotSelected" onclick="generateGanttChart(event)" />

    <!-- Show Selected-->
    <label for="showOnlySelected" title="Show Selected">Selected:</label>
    <input type="checkbox" id="showOnlySelected" onclick="generateGanttChart(event)" />


  </div> <!-- End <div id="options"> -->
  </div> <!-- End <div id="tab9" class="tab-content"> -->

  </div> <!-- End <div class="tab-content-container"> -->
  </div> <!-- End <div class="tab-container"> -->
</div> <!-- End <div id="inputArea"> -->
</div> <!-- End <div id="htmlScaleWrapper"> -->

<div id="svgContainer"></div>
</div> <!-- End <div id="layoutWrapper"> -->

<script>

  function unifiedScale() {
      const baseWidth  = 800;   // total designed width of HTML + SVG
      const baseHeight = 600;   // total designed height of HTML + SVG
      const scaleX = window.innerWidth / baseWidth;
      const scaleY = window.innerHeight / baseHeight;
      const preserveAspect = true;  // <--- change to true if you want uniform scaling
      let finalScaleX = scaleX;
      let finalScaleY = scaleY;
      if (preserveAspect) {
          const s = Math.min(scaleX, scaleY);
          finalScaleX = s;
          finalScaleY = s;
      }
      const wrapper = document.getElementById("layoutWrapper");
      wrapper.style.transform =
          `scale(${finalScaleX.toFixed(3)}, ${finalScaleY.toFixed(3)})`;
      // OPTIONAL:
      // If you want to center the scaled content, you can adjust wrapperâ€™s left/top via JS.
  }
  unifiedScale(); // Initial run
  window.addEventListener("resize", unifiedScale); // Update on resize

  const svgNS = "http://www.w3.org/2000/svg";

  function openTab(event, tabId) {
    // Hide all tab content
    document.querySelectorAll('.tab-content').forEach(tab => {
      tab.classList.remove('active');
    });
    // Remove active class from all tab buttons
    document.querySelectorAll('.tab-button').forEach(btn => {
      btn.classList.remove('active');
    });
    // Show the selected tab content
    document.getElementById(tabId).classList.add('active');
    // Add active class to the clicked tab button
    event.currentTarget.classList.add('active');
  }

  document.getElementById('todayDate').value = todayDate()
  function todayDate() {
    const today = new Date();
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0'); // Month is zero-based
    const day = String(today.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`; // Format as YYYY-MM-DD
  }

  document.getElementById('projectStartDate').value = todayDateMinusOneMonth()
  function todayDateMinusOneMonth() {
    const today = new Date();
    const todayMinusOneMonth = new Date(today);
    todayMinusOneMonth.setMonth(today.getMonth() - 1);
    const year = todayMinusOneMonth.getFullYear();
    const month = String(todayMinusOneMonth.getMonth() + 1).padStart(2, '0'); // Month is zero-based
    const day = String(todayMinusOneMonth.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`; // Format as YYYY-MM-DD
  }

  let nextAlertConfirmed = true;
  function alertWithConfirmation(alertMessage) {
    if (nextAlertConfirmed) {
      nextAlertConfirmed = confirm(alertMessage + 
                                   "\n\n" + 
                                   "Press OK to show possible additional alerts or Cancel to skip possible additional alerts\n")
    }
  }

  //Multi-select selector to select tasks/bars to apply settings
  function createTasksSelectorControl(tasks) {
    const multiSelectControl = document.createElement("select");
    multiSelectControl.id = "taskIdSelector";
    multiSelectControl.multiple = true;
      
    tasks.forEach(task => {
      const optionControl = document.createElement("option");
      optionControl.value = task.id;
      optionControl.textContent = task.id;
      optionControl.id = "task.id"+task.id;
      optionControl.selected = true;
      multiSelectControl.appendChild(optionControl);
    });
    const labelForMultiSelectControl = document.createElement("label");
    labelForMultiSelectControl.id = "labelForTaskIdSelector"
    labelForMultiSelectControl.setAttribute("for", "taskIdSelector");
    labelForMultiSelectControl.textContent = "Settings to Ids";
    labelForMultiSelectControl.title = "Select one or more task Ids to apply the settings selected in Bars, Tasks, or Dates Settings tabs. Press Ctrl/click or Shift/click to select multiple task Ids";
    const tasksSelector = document.getElementById("tasksSelector");
    if (tasksSelector) {
      tasksSelector.appendChild(labelForMultiSelectControl);
      tasksSelector.appendChild(multiSelectControl);
    } else {
      console.log("Element with ID 'tasksSelector' not found.");
    }
  }

  function updateOptionsInTasksSelectorControl(tasks) {
    const taskIdSelector = document.getElementById("taskIdSelector");
    while (taskIdSelector.options.length > 0) {
      taskIdSelector.remove(0);
    }
    tasks.forEach(task => {
      const optionControl = document.createElement("option");
      optionControl.value = task.id;
      optionControl.textContent = task.id;
      optionControl.id = "task.id" + task.id;
      optionControl.selected = true;
      taskIdSelector.appendChild(optionControl);
    });
  }

  function isTaskInSelectedTasks(taskId) {
    const multiSelect = document.getElementById("taskIdSelector");
    const selectedTaskIds = Array.from(multiSelect.selectedOptions).map(option => option.value);
    return selectedTaskIds.includes(taskId.toString());
  }

  // Utility to detect boolean-like strings
  function isBooleanLike(value) {
    if (value == null) return false;
    const val = value.toString().trim().toLowerCase();
    return ["true", "false", "yes", "no"].includes(val);
  }

  // Utility to detect numeric-like strings (e.g., IDs)
  function isNumericLike(value) {
    return !isNaN(parseInt(value, 10));
  }

  // Critical Path Method (CPM) implementation - parse of the input CSV text 
  function parseCSV(data, percentCompleteMultiplier, projectStartDate, todayDate) {
    try {
      if (!data || data.trim().length === 0) {
        return []; // safely return an empty task list
      }
      const nonWorkingDates = getNonWorkingDatesConfig();
      const oneDayMs = 24 * 60 * 60 * 1000;
      let projectStart = new Date(projectStartDate);
      while (isNonWorkingDay(projectStart, nonWorkingDates)) {
        projectStart = new Date(projectStart.getTime() + oneDayMs);
      }
      const today = new Date(todayDate);
      // Determine the separator (comma or tab) based on the first row
      const separator = data.includes('\t') ? '\t' : ',';
      // Split the data into rows skipping blank rows
      const rows = (data.trim().split('\n')).filter(line => line.trim().length > 0);
      // Map each row into a task object
      const tasks = rows.map(row => {
        const cols = row.split(separator);
        // --- For backward compatibility: chech if parent column exist (parent column is optional in the version 2.0 of the software)
        let parentValue = false;
        let parentIdValue = 0;
        // Clean trailing empty columns
        while (cols.length > 0 && cols[cols.length - 1].trim() === "") cols.pop();
        if (cols.length >= 6) {
          const candidate = cols[5]?.trim();
          if (candidate === "" && cols.length >= 7 && isNumericLike(cols[6])) {
            // Case 1: "extra comma" empty parent column â†’ skip it and use next one as parentId
            parentValue = false;
            parentIdValue = parseInt(cols[6], 10);
          } else if (isBooleanLike(candidate)) {
            // Case 2: explicit boolean parent column
            parentValue = parseBoolean(candidate);
            parentIdValue = isNumericLike(cols[6]) ? parseInt(cols[6], 10) : 0;
          } else if (isNumericLike(candidate)) {
            // Case 3: parent column omitted, candidate is parentId
            parentValue = false;
            parentIdValue = parseInt(candidate, 10);
          } else {
            // Case 4: unexpected or blank â€” treat as no parent, no parentId
            parentValue = false;
            parentIdValue = 0;
          }
        } else if (cols.length === 5) {
          // Case 5: CSV ends at predecessors (no parent or parentId)
          parentValue = false;
          parentIdValue = 0;
        }
        // Create Tasks object with initial values
        const task = {
          id: parseInt(cols[0], 10),
          name: cols[1],
          duration: parseInt(cols[2], 10),
          percentComplete: percentCompleteMultiplier ? parseFloat(cols[3])*100 : parseFloat(cols[3]),
          idealPercentComplete: 0,
          earliestStartDate: new Date(projectStart),
          earliestFinishDate: new Date(projectStart),
          latestStartDate: new Date(projectStart),
          latestFinishDate: new Date(projectStart),
          startDate: new Date(projectStart),
          endDate: new Date(projectStart),
          predecessors: cols[4] ? parsePredecessors(cols[4]) : [],
          elapsed: 0,
          totalFloat: 0,
          critical: false,
          delay: false,
          milestone: false,
          parent: parentValue,
          parentId: parentIdValue,
          depth: 0,
          startX: 0,
          startY: 0,
          endX: 0,
          endY: 0
        };
        if (task.predecessors.some(p => p.id === task.id)) {
          alertWithConfirmation(`Invalid dependency in CSV: Task ${task.id} - ${task.name} cannot reference itself as a predecessor.`);
          throw new Error();
        }
        if (task.parentId === task.id) {
          alertWithConfirmation(`Invalid parent Id in CSV: Task ${task.id} - ${task.name} cannot reference itself as a parent task.`);
          throw new Error();
        }
        return task;
      });

      // Set Dates, Elapsed, Depth

      // Add original index to tasks
      tasks.forEach((task, index) => {
        task.originalIndex = index;
      });
      // First Pass - Critical Path Method (CPM)
      let sortedTasks = topologicalSort(tasks); // Sort the tasks with those without predecessors at the top
      let snapshotSortedTasks = JSON.parse(JSON.stringify(sortedTasks));
      forwardPassForEarliestDates(sortedTasks, nonWorkingDates, projectStart); // Earliest Start/Finish Dates and Elapsed (Forward Pass)
      let reversedTasks = [...sortedTasks].reverse(); // Prepare for backward pass
      backwardPassForLatestDates(reversedTasks, nonWorkingDates); // Latest Start/Finish Dates (Backward Pass)
      adaptParentTasks(reversedTasks, today, nonWorkingDates); // Adapt parent tasks for Dates, Elapsed, and Durations
      // Following passes (CPM)
      let counter = 0;
      while (!checkParentTasksForElapsedAndDurationAndDates(snapshotSortedTasks, [...reversedTasks].reverse())){
        sortedTasks = topologicalSort([...reversedTasks].reverse()); 
        snapshotSortedTasks = JSON.parse(JSON.stringify(sortedTasks));
        forwardPassForEarliestDates(sortedTasks, nonWorkingDates, projectStart);
        reversedTasks = [...sortedTasks].reverse();
        backwardPassForLatestDates(reversedTasks, nonWorkingDates);
        adaptParentTasks(reversedTasks, today, nonWorkingDates);
        counter++;
        if (counter > 10) break; // to avoid possible infinite loop
      }

      // Find the project duration in days
      const allDates = reversedTasks.flatMap(task => [task.startDate, task.endDate]);
      const minDate = new Date(Math.min(...allDates));
      const maxDate = new Date(Math.max(...allDates));
      const projectElapsed = (maxDate - minDate) / oneDayMs;
      // Set Total Floats, Critical Tasks 
      reversedTasks.forEach(task => {
        // Set Total Float
        task.totalFloat = (task.latestStartDate.getTime() - task.earliestStartDate.getTime()) / 24 / 60 / 60 / 1000;
        // Find all paths of each task and evaluate their durations
        const paths = findPaths(task, reversedTasks);
        paths.forEach(path => {
          const pathDates = path.flatMap(t => [t.startDate, t.endDate]);
          const pathMinDate = new Date(Math.min(...pathDates));
          const pathMaxDate = new Date(Math.max(...pathDates));
          const pathElapsed = (pathMaxDate - pathMinDate) / oneDayMs;
          // Mark tasks in the longest path with total float === 0 as critical
          if (pathElapsed >= projectElapsed) { 
            path.forEach(t => {
              // Set critical task
              if (t.totalFloat===0) {
                t.critical = true;
              }
            });
          }
        });
        // Set Ideal Percentage, Delay, Milestones
        task.milestone = (task.duration === 0);
        const actualElapsed = Math.max(0, Math.min((today - task.startDate) / oneDayMs, task.elapsed)); // Clamp to [0, totalDuration]
        task.idealPercentComplete = task.elapsed > 0 ? (actualElapsed / task.elapsed) * 100 : 0;
        if (task.milestone && today >= task.startDate) task.idealPercentComplete = 100;
        task.delay = task.percentComplete < task.idealPercentComplete;
      });
      //Rollback tasks to original order
      reversedTasks.sort((a, b) => a.originalIndex - b.originalIndex);
      //Remove the originalIndex property
      reversedTasks.forEach(task => {
        delete task.originalIndex;
      });

      return reversedTasks;

    } catch (error) {
      //const errorContainer = document.getElementById("errorContainer");
      alertWithConfirmation("Error parsing the CSV Project Schedule:\nThe CSV of the Project Schedule is not formatted correctly\n" + error);
      console.log(error);
      return []; // Return an empty array to prevent further issues
    }

    // Helper function: Forward pass in Critical Path Method to calculate Earliest Start and Finish Dates 
    function forwardPassForEarliestDates(tasks, nonWorkingDates, projectStartDate) {
      const oneDayMs = 24 * 60 * 60 * 1000;
      tasks.forEach(task => {
        if (task.predecessors.length > 0) {
          const validTimestamps = task.predecessors.map(pred => {
            const predTask = tasks.find(t => t.id === pred.id);
            if (!predTask) {
              alertWithConfirmation(`Task ${task.id} - ${task.name} has a missing predecessor ID: ${pred.id}`);
              return Number.NEGATIVE_INFINITY;
            }
            let leadLag = pred.leadLag || 0;
            leadLag = (leadLag >= 0) ? leadLag + 1 : leadLag - 1; 
            let calculatedDate;
            let predEarliestStartDate = new Date(predTask.earliestStartDate);
            let predEarliestFinishDate = new Date(predTask.earliestFinishDate);
            switch (pred.dependencyType) {
              case "FS": // Finish-to-Start
                if (task.duration !== 0) {
                  predEarliestFinishDate = new Date (predEarliestFinishDate.getTime() + oneDayMs);
                  while (isNonWorkingDay(predEarliestFinishDate, nonWorkingDates)) {
                    predEarliestFinishDate = new Date (predEarliestFinishDate.getTime() + oneDayMs);
                  }                 
                }
                calculatedDate = new Date(
                  predEarliestFinishDate.getTime() 
                  + getElapsed(predEarliestFinishDate, leadLag, nonWorkingDates) * oneDayMs);
                break;
              case "SS": // Start-to-Start
                calculatedDate = new Date(
                  predEarliestStartDate.getTime() 
                  + getElapsed(predEarliestStartDate, leadLag, nonWorkingDates) * oneDayMs);
                break;
              case "FF": // Finish-to-Finish
                predEarliestFinishDate = new Date (
                  predEarliestFinishDate.getTime() 
                  + getElapsed(predEarliestFinishDate, leadLag, nonWorkingDates) * oneDayMs);
                calculatedDate = new Date(
                  predEarliestFinishDate.getTime() 
                  + getElapsed(predEarliestFinishDate, -task.duration, nonWorkingDates) * oneDayMs);
                break;
              case "SF": // Start-to-Finish
                if (task.duration !== 0) {                
                  predEarliestStartDate = new Date (predEarliestStartDate.getTime() - oneDayMs);
                  while (isNonWorkingDay(predEarliestStartDate, nonWorkingDates)) {
                    predEarliestStartDate = new Date (predEarliestStartDate.getTime() - oneDayMs);
                  }
                }
                predEarliestStartDate = new Date (
                  predEarliestStartDate.getTime() 
                  + getElapsed(predEarliestStartDate, leadLag, nonWorkingDates) * oneDayMs);
                calculatedDate = new Date(
                  predEarliestStartDate.getTime() 
                  + getElapsed(predEarliestStartDate, -task.duration, nonWorkingDates) * oneDayMs);
                break;
              default:
                alertWithConfirmation(`Unknown dependency type: ${pred.dependencyType}`);
                return Number.NEGATIVE_INFINITY;
            }
            return calculatedDate.getTime();
          }).filter(ts => ts !== Number.NEGATIVE_INFINITY);
          if (validTimestamps.length > 0) {
            task.earliestStartDate = new Date(Math.max(...validTimestamps));
          } else {
            alertWithConfirmation(`Date for task ID ${task.id} - ${task.name} set to project start date`);
            task.earliestStartDate = new Date(projectStartDate); // Fallback to project start date
          }
        }
        if (!isNaN(task.earliestStartDate)) {
          task.elapsed = getElapsed(task.earliestStartDate, task.duration, nonWorkingDates);
          task.earliestFinishDate = new Date(task.earliestStartDate.getTime() + task.elapsed * oneDayMs);
        } else {
          console.error(`Invalid earliestStartDate for task ID: ${task.id}`);
        }
        task.startDate = task.earliestStartDate;
        task.endDate = task.earliestFinishDate;
      });
    }

    // Helper function: Backward pass in Critical Path Method to calculate Latest Start and Finish Dates 
    function backwardPassForLatestDates(tasks, nonWorkingDates) {
      const oneDayMs = 24 * 60 * 60 * 1000;
      tasks.forEach(task => {
        const finishCandidates = tasks
          .filter(t => t.predecessors.some(p => p.id === task.id))
          .map(dep => {
            const predecessor = dep.predecessors.find(p => p.id === task.id);
            let leadLag = predecessor?.leadLag || 0;
            leadLag = (leadLag >= 0) ? -leadLag - 1 : -leadLag + 1;
            let calculatedDate;
            let depLatestStartDate = new Date(dep.latestStartDate);
            let depLatestFinishDate = new Date(dep.latestFinishDate);
            switch (predecessor?.dependencyType) {
              case "FS": // Finish-to-Start
                if (dep.duration !== 0) {
                  depLatestStartDate = new Date(depLatestStartDate.getTime() - oneDayMs);
                  while (isNonWorkingDay(depLatestStartDate, nonWorkingDates)) {
                    depLatestStartDate = new Date(depLatestStartDate.getTime() - oneDayMs);
                  }
                }
                calculatedDate = new Date(
                  depLatestStartDate.getTime() 
                  + getElapsed(depLatestStartDate, leadLag, nonWorkingDates) * oneDayMs);
                break;
              case "SS": // Start-to-Start
                calculatedDate = new Date(
                  depLatestStartDate.getTime() 
                  + task.elapsed * oneDayMs 
                  + getElapsed(depLatestStartDate, leadLag, nonWorkingDates) * oneDayMs);
                break;
              case "FF": // Finish-to-Finish
                calculatedDate = new Date(
                  depLatestFinishDate.getTime() 
                  + getElapsed(depLatestFinishDate, leadLag, nonWorkingDates) * oneDayMs);
                break;
              case "SF": // Start-to-Finish
                if (dep.duration !== 0) {
                  depLatestFinishDate =  new Date(depLatestFinishDate.getTime() + oneDayMs);
                  while (isNonWorkingDay(depLatestFinishDate, nonWorkingDates)) {
                    depLatestFinishDate =  new Date(depLatestFinishDate.getTime() + oneDayMs);
                  }
                }
                calculatedDate = new Date(
                  depLatestFinishDate.getTime() 
                  + task.elapsed * oneDayMs 
                  + getElapsed(depLatestFinishDate, leadLag, nonWorkingDates) * oneDayMs);
                break;
              default:
                alertWithConfirmation(`Unknown dependency type: ${predecessor?.dependencyType}`);
                calculatedDate = new Date(
                  dep.latestStartDate.getTime() 
                  + getElapsed(dep.latestStartDate, leadLag, nonWorkingDates) * oneDayMs);
              }
            return calculatedDate.getTime();
          });
          if (finishCandidates.length) {
            task.latestFinishDate = new Date(Math.min(...finishCandidates));
          } else {
            task.latestFinishDate = task.earliestFinishDate;
          }
          if (!isNaN(task.latestFinishDate)) {
            task.latestStartDate = new Date(task.latestFinishDate.getTime() - task.elapsed * oneDayMs);
          } else {
            console.error(`Invalid latestFinishDate for task ID: ${task.id}`);
          }
      });
    }

    // Helper function: Adjust/adapt parent tasks on the base of the children tasks values 
    function adaptParentTasks(tasks, today, nonWorkingDatesConfig) {
      const oneDayMs = 1000 * 60 * 60 * 24;
      // Precompute depth for each task
      tasks.forEach(t => t.depth = getDepth(tasks, t));
      // Process from deepest to shallowest
      const sorted = [...tasks].sort((a, b) => b.depth - a.depth);
      for (const task of sorted) {
        const children = getAllDescendants(tasks, task);
        if (children.length === 0) continue;
        if (task.predecessors[0])
          alertWithConfirmation(`Invalid predecessors in parent task. Task ${task.id} - ${task.name} - is a parent task and cannot have predecessors.`);
        // Aggregate children values to parent dates
        task.earliestStartDate = new Date(Math.min(...children.map(c => +new Date(c.earliestStartDate))));
        task.latestStartDate   = new Date(Math.min(...children.map(c => +new Date(c.latestStartDate))));
        task.startDate         = new Date(Math.min(...children.map(c => +new Date(c.startDate))));
        task.earliestFinishDate= new Date(Math.max(...children.map(c => +new Date(c.earliestFinishDate))));
        task.latestFinishDate  = new Date(Math.max(...children.map(c => +new Date(c.latestFinishDate))));
        task.endDate           = new Date(Math.max(...children.map(c => +new Date(c.endDate))));
        // Elapsed & Duration
        const minDate = new Date(Math.min(...children.map(c => +new Date(c.startDate))));
        const maxDate = new Date(Math.max(...children.map(c => +new Date(c.endDate))));
        task.elapsed = (maxDate - minDate) / oneDayMs; 
        if (task.elapsed === 0) {
          task.duration = 0;
          for (const c of children) {
            if (c.duration != 0) task.duration = c.duration;
            break;
          }
        } else
          task.duration = getDuration(minDate, task.elapsed, nonWorkingDatesConfig);
        // Weighted % complete, cleaning of predecessors from children to parent
        let totalDuration = 0, weightedPercentComplete = 0;
        for (const c of children) {
          // Weighted % complete
          const d = parseFloat(c.duration) || 0;
          totalDuration += d;
          weightedPercentComplete += (parseFloat(c.percentComplete) || 0) * d;
          // Clean predecessors linking to parent, in children
          if (Array.isArray(c.predecessors))
            c.predecessors = c.predecessors.filter(p => p.id !== task.id);
          else if (typeof c.predecessors === "string")
            c.predecessors = c.predecessors
              .split(/;|,/)
              .map(s => s.trim())
              .filter(s => s && !s.startsWith(task.id.toString()))
              .join(";");
        }
        task.percentComplete = totalDuration ? Math.round((weightedPercentComplete / totalDuration) * 10) / 10 : 0;
        task.parent = true; // We are in a parent task 
      }
    }

    function checkParentTasksForElapsedAndDurationAndDates(tasks1, tasks2) {
      if (!Array.isArray(tasks1) || !Array.isArray(tasks2) || tasks1.length !== tasks2.length) {
        console.log("Input arrays are invalid or not the same length.");
        return false;
      }
      for (let i = 0; i < tasks1.length; i++) {
        const t1 = tasks1[i];
        const t2 = tasks2[i];
        // Check matching IDs
        if (t1.id !== t2.id) {
          return false;
        }
        // Compare duration
        if (t1.duration !== t2.duration) {
          return false;
        }
        // Compare elapsed
        if (t1.elapsed !== t2.elapsed) {
          return false;
        }
        // Compare start dates
        if ((new Date(t1.startDate)).getTime() !== (new Date(t2.startDate)).getTime()) {
          return false;
        }
        // Compare end dates
        if ((new Date(t1.endDate)).getTime() !== (new Date(t2.endDate)).getTime()) {
          return false;
        }
      }
      return true; // All tasks match
    }    

    function getAllDescendants(tasks, taskOrId) {
      const parentId = typeof taskOrId === "object" ? taskOrId.id : taskOrId;
      const descendants = [];
      const stack = [parentId];
      while (stack.length > 0) {
        const currentParentId = stack.pop();
        const directChildren = tasks.filter(t => t.parentId === currentParentId);
        for (const child of directChildren) {
          descendants.push(child);
          stack.push(child.id);
        }
      }
      return descendants;
    }
    
    function getDepth(tasks, taskOrId) {
      if (!Array.isArray(tasks) || tasks.length === 0) return 0;
      const targetId = typeof taskOrId === "object" ? taskOrId.id : taskOrId;
      const visited = new Set();
      let depth = 0;
      let currentTask = tasks.find(t => t.id === targetId);
      while (currentTask && currentTask.parentId && currentTask.parentId !== 0) {
        if (visited.has(currentTask.parentId)) {
          console.warn("Detected circular parent reference at task", currentTask.id);
        break; // avoid infinite loop
        }
        visited.add(currentTask.parentId);
        const parent = tasks.find(t => t.id === currentTask.parentId);
        if (!parent) break;
        depth++;
        currentTask = parent;
      }
      return depth;
    }

    // Helper function: Topological sort
    function topologicalSort(tasks) {
      const graph = new Map();
      const inDegree = new Map();
      // Initialize the graph and in-degree map
      tasks.forEach(task => {
        graph.set(task.id, []);
        inDegree.set(task.id, 0);
      });
      // Build the graph and calculate in-degrees
      tasks.forEach(task => {
        task.predecessors.forEach(pred => {
          if (graph.has(pred.id)) {
            graph.get(pred.id).push(task.id);
            inDegree.set(task.id, (inDegree.get(task.id) || 0) + 1);
          }
        });
      });
      // Perform topological sorting using Kahn's algorithm
      const sortedTasks = [];
      const queue = [];
      // Start with nodes that have no incoming edges
      inDegree.forEach((degree, id) => {
        if (degree === 0) queue.push(id);
      });
      while (queue.length > 0) {
        const current = queue.shift();
        sortedTasks.push(current);
        // Reduce the in-degree of neighbors
        graph.get(current).forEach(neighbor => {
          inDegree.set(neighbor, inDegree.get(neighbor) - 1);
          if (inDegree.get(neighbor) === 0) queue.push(neighbor);
        });
      }
      return sortedTasks.map(id => tasks.find(task => task.id === id));
    }
        
    // Helper function to find paths recursively
    function findPaths(task, tasks, visited = new Set(), currentPath = []) {
      if (visited.has(task.id)) {
        // Skip fallback-induced revisits (not a real dependency loop)
        return [];
      }
      visited.add(task.id);
      currentPath.push(task);
      let successors = tasks.filter(t =>
        t.predecessors.some(p => p.id === task.id)
      );
      if (successors.length === 0) {
        let ancestorId = task.parentId;
        while (ancestorId) {
          const ancestor = tasks.find(t => t.id === ancestorId);
          if (!ancestor) break;
          const ancestorSuccessors = tasks.filter(t =>
            t.predecessors.some(p => p.id === ancestor.id)
          );
          if (ancestorSuccessors.length > 0) {
            successors = successors.concat(ancestorSuccessors);
            break; // stop at the first ancestor that has successors
          }
          ancestorId = ancestor.parentId; // move up the hierarchy
        }
      }
      if (successors.length === 0) {
        // End of a path
        return [currentPath];
      }
      //successors = successors.filter(s => !visited.has(s.id));
      let paths = [];
      for (const successor of successors) {
        paths = paths.concat(findPaths(successor, tasks, new Set(visited), [...currentPath]));
      }
      return paths;
    }

  } //End of parseCSV

  // Utility function to check if a day is non-working
  function isNonWorkingDay(date, nonWorkingDatesConfig) {
    const day = date.getDay(); // 0: Sunday, 6: Saturday
    const formattedDate = date.toISOString().split('T')[0]; // Format as YYYY-MM-DD
    return (
        (nonWorkingDatesConfig.saturdayNonWorking && day === 6) ||
        (nonWorkingDatesConfig.sundayNonWorking && day === 0) ||
        nonWorkingDatesConfig.nonWorkingDates.includes(formattedDate)
    );
  }

  function getElapsed(startDate, duration, nonWorkingDatesConfig) {
    const { saturdayNonWorking, sundayNonWorking, nonWorkingPeriods, nonWorkingDates } = nonWorkingDatesConfig;
    const oneDayMs = 24 * 60 * 60 * 1000;
    let elapsedDays = 0;
    let workingDaysAdded = 0;
    let currentDate = new Date(startDate);
    if (duration > 0) {
      // Ensure the start date is a working day      
      while (isNonWorkingDay(currentDate, nonWorkingDatesConfig)) {
        currentDate = new Date (currentDate.getTime() + oneDayMs);
        elapsedDays++;
      }
      // Forward calculation for positive duration
      workingDaysAdded = 1;
      while (workingDaysAdded < duration) {
        if (!isNonWorkingDay(currentDate, nonWorkingDatesConfig)) {
          workingDaysAdded++;
        }
        elapsedDays++;
        currentDate = new Date (currentDate.getTime() + oneDayMs);
      }
      // Ensure the final date is a working day
      while (isNonWorkingDay(currentDate, nonWorkingDatesConfig)) {
        currentDate = new Date (currentDate.getTime() + oneDayMs);
        elapsedDays++;
      }
    } else if (duration < 0) {
      // Ensure the start date is a working day
      while (isNonWorkingDay(currentDate, nonWorkingDatesConfig)) {
        currentDate = new Date (currentDate.getTime() - oneDayMs);
        elapsedDays--;
      }
      // Backward calculation for negative duration
      workingDaysAdded = -1;
      while (workingDaysAdded > duration) {
        if (!isNonWorkingDay(currentDate, nonWorkingDatesConfig)) {
          workingDaysAdded--;
        }
        elapsedDays--;
        currentDate = new Date (currentDate.getTime() - oneDayMs);
      }
      // Ensure the final date is a working day
      while (isNonWorkingDay(currentDate, nonWorkingDatesConfig)) {
        currentDate = new Date (currentDate.getTime() - oneDayMs);
        elapsedDays--;
      }
    }
    return elapsedDays;
  }

  function getDuration(startDate, elapsed, nonWorkingDatesConfig) {
    const oneDayMs = 24 * 60 * 60 * 1000;
    let currentDate = new Date(startDate);
    let workingDays = 0;
    if (elapsed > 0) {
      workingDays = 1;
      for (let i = 0; i < elapsed; i++) {
        if (!isNonWorkingDay(currentDate, nonWorkingDatesConfig)) {
          workingDays++;
        }
        currentDate = new Date (currentDate.getTime() + oneDayMs);
      }
    } else if (elapsed < 0) {
      workingDays = -1;
      for (let i = 0; i > elapsed; i--) {
        if (!isNonWorkingDay(currentDate, nonWorkingDatesConfig)) {
          workingDays--;
        }
        currentDate = new Date (currentDate.getTime() - oneDayMs);
      }
    }
    return workingDays;
  }

  function consoleLog(tasks) {
    tasks.forEach(task => {
        console.log(
          "id: "+task.id+"\n"+
          "name: "+task.name+"\n"+
          "duration: "+task.duration+"\n"+
          "percentComplete: "+task.percentComplete+"\n"+
          "idealPercentComplete: "+task.idealPercentComplete+"\n"+
          "earliestStartDate: "+task.earliestStartDate+"\n"+
          "earliestFinishDate: "+task.earliestFinishDate+"\n"+
          "latestStartDate: "+task.latestStartDate+"\n"+
          "latestFinishDate: "+task.latestFinishDate+"\n"+
          "startDate: "+task.startDate+"\n"+
          "endDate: "+task.endDate+"\n"+
          "predecessors: "+task.predecessors.map(p => String(p.id) + " " + String(p.dependencyType) + " " + String(p.leadLag))+"\n"+
          "elapsed: "+task.elapsed+"\n"+
          "totalFloat: "+task.totalFloat+"\n"+
          "parent task: "+task.parent+"\n"+
          "critical: "+task.critical+"\n"+
          "delay: "+task.delay+"\n"+
          "milestone: "+task.milestone+"\n"+
          "startX: "+task.startX+"\n"+
          "startY: "+task.startY+"\n"+
          "endX: "+task.endX+"\n"+
          "endY: "+task.endY+"\n"
        )
    })
  }

  function toCSV(tasks, datesFormat) {
    CSV = "Id, Name, Duration, Percent Complete, Predecessors, Parent Id, Depth, Elapsed Duration, Total Float, Ideal Percent Complete, Earlier Start Date, Earliest Finish Date, Latest Start Date, Latest Finish Date, Start Date, Finish Date, Parent, Critical, Delay, Milestone\n";
    tasks.forEach(task => {
        CSV = CSV + 
          String(task.id)+","+
          (String(task.name)).replace(/,/g, " &")+","+
          String(task.duration)+","+
          String(task.percentComplete)+","+
          String(task.predecessors.map(p => String(p.id) + String(p.dependencyType) + String(p.leadLag)).join(";")) + "," +
          String(task.parentId)+","+
          String(task.depth)+","+
          String(task.elapsed)+","+
          String(task.totalFloat)+","+
          String(task.idealPercentComplete)+","+
          String(formatDate(task.earliestStartDate, datesFormat))+","+
          String(formatDate(task.earliestFinishDate, datesFormat))+","+
          String(formatDate(task.latestStartDate, datesFormat))+","+
          String(formatDate(task.latestFinishDate, datesFormat))+","+
          String(formatDate(task.startDate, datesFormat))+","+
          String(formatDate(task.endDate, datesFormat))+","+
          String(task.parent)+","+
          String(task.critical)+","+
          String(task.delay)+","+
          String(task.milestone)+"\n";
    })
    return CSV
  }

  function parsePredecessors(predecessors) {
      const regex = /\b(\d+)([FS]{2})?(?:([+-]?\d+)\s*(?:day(?:s)?)?)?\b/g;
      const result = [];
      let match;
      while ((match = regex.exec(predecessors)) !== null) {
          result.push({
              id: parseInt(match[1], 10),
              dependencyType: match[2] || "FS",
              leadLag: match[3] ? parseInt(match[3], 10) : 0
          });
      }
      return result;
  }

  function parseBoolean(value) {
    if (typeof value === "string") {
        const normalized = value.trim().toLowerCase();
        if (normalized === "false" || normalized === "f") {
            return false;
        }
    }
    return Boolean(value);
  }  

  function calculateTimeline(tasks) {
    try {
       const uniqueStartDates = Array.from(new Set(tasks.map(t => t.startDate.toISOString().split('T')[0])))
         .map(d => new Date(d))
         .sort((a, b) => a - b);
       const minDate = new Date(Math.min(...uniqueStartDates));
       const maxDate = new Date(Math.max(...tasks.map(t => t.endDate)));
       return { minDate, maxDate, uniqueStartDates };
    } catch (error) {
       //const errorContainer = document.getElementById("errorContainer");
       alertWithConfirmation("Error calculating the timeline:\nThe CSV of the Project Schedule is not formatted correctly");
       return null; // Return an empty object to prevent further issues
     }  
  }

  async function exportGanttChartAsSVG() {
    try {
      const svgElement = document.getElementById("ganttChart");

      if (!svgElement) {
         alertWithConfirmation("No Gantt chart found to export!\nView the Gantt Chart before exporting it to SVG");
         return;
      }

      // If in edit mode, sync all current input values before exporting
      const editMode = document.getElementById("editMode") ? (document.getElementById("editMode")).checked : false;
      if (editMode) {
        syncInputValuesToAttributes(svgElement);
      }
      // Clone the SVG element to avoid modifying the original
      const clonedSvg = svgElement.cloneNode(true);
      // Ensure the exported SVG includes the current viewBox
      const viewBox = svgElement.getAttribute("viewBox");
      if (viewBox) {
        clonedSvg.setAttribute("viewBox", viewBox);
      }
      // Serialize the SVG element to a string
      const serializer = new XMLSerializer();
      //const svgContent = serializer.serializeToString(svgElement);
      const svgContent = serializer.serializeToString(clonedSvg);
      // Create a blob with the SVG content and a downloadable link
      const blob = new Blob([svgContent], { type: "image/svg+xml" });
      //const link = document.createElement("a");

      if (window.showSaveFilePicker) {
        const fileHandle = await window.showSaveFilePicker({
          suggestedName: "gantt_chart.svg",
            types: [{
                   description: "SVG File",
                   accept: { "image/svg+xml": [".svg"] }
                   }]
          });
        // Create a writable stream and write the CSV to the file
        const writableStream = await fileHandle.createWritable();
        await writableStream.write(blob);
        await writableStream.close();
        alertWithConfirmation("File saved successfully!");
      } else {
            // Fallback: Create a temporary <a> element for downloading
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "gantt_chart.svg";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            alertWithConfirmation("File downloaded successfully!");
        }        
    } catch (error) {
      console.error("Error saving SVG file:", error);
      alertWithConfirmation("Failed to save file. Make sure your browser supports the File System Access API.");
    } 
  }

  /**
  * Ensure all <input> fields inside SVG have their current .value property
  * written back to the "value" attribute before export.
  */
  function syncInputValuesToAttributes(svg) {
    const inputs = svg.querySelectorAll("foreignObject input");
    inputs.forEach(input => {
      input.setAttribute("value", input.value);
    });
  }

  function formatDate(date, format) {
    const formatLocaleMapping = {
      "MM/DD/YYYY": "en-US", // US English
      "DD/MM/YYYY": "en-GB", // British English
      "YYYY-MM-DD": "ja-JP", // Japanese
      "MMM DD, YYYY": "en-US", // US English
      "DD MMM YYYY": "en-GB", // British English
    };
    const locale = formatLocaleMapping[format] || "en-US"; // Default to US English
    const options = {
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
    };

    switch (format) {
      case "MM/DD/YYYY":
        return date.toLocaleDateString(locale, options); // Default order in en-US
      case "DD/MM/YYYY":
        return date.toLocaleDateString(locale, options); // Default order in en-GB
      case "YYYY-MM-DD":
        return date.toLocaleDateString(locale, options).replace(/\//g, "-"); // Adapt for ja-JP style
      case "MMM DD, YYYY":
        return date.toLocaleDateString(locale, { year: "numeric", month: "short", day: "2-digit" });
      case "DD MMM YYYY":
        const [day, month, year] = date
          .toLocaleDateString(locale, { year: "numeric", month: "short", day: "2-digit" })
          .split(" ");
        return `${day} ${month} ${year}`;
      default:
        return date.toLocaleDateString(locale); // Fallback to locale default
    }
  }

  function createGanttChart(notFilteredTasks, minDate, maxDate, todayDate, uniqueStartDates, event, options) {
    const {leftMargin, 
           verticalShift, 
           offsetZeroX, 
           chartWidth, 
           rightMargin, 
           barHeight, 
           barSpace, 
           percentCompleteColor, 
           percentNotCompleteColor,
           strokeColor,
           barBorderThickness,
           barAngles,
           axesWidth,
           axesColor,
           verticalLinesWidth,
           verticalLinesColor,
           horizontalSeparatorsWidth,
           horizontalSeparatorsColor,
           tasksCharSize,
           tasksCharFamily,
           tasksCharStyle,
           tasksCharWeight,
           tasksCharColor,
           tasksTruncate,
           tasksDetailedInfo_0,
           tasksDetailedInfo_1,
           tasksDetailedInfo_2,
           parentPercentNotCompleteColor,
           parentPercentCompleteColor,
           parentBarAngles,
           parentsCharSize,
           parentsCharFamily,
           parentsCharStyle,
           parentsCharWeight,
           parentsCharColor,
           delayCharSize,
           delayCharFamily,
           delayCharStyle,
           delayCharColor,
           datesCharSize,
           datesCharFamily,
           datesFormat,
           datesCharStyle,
           datesCharWeight,
           datesCharColor,
           dependenciesLineColor,
           dependenciesLineWidth,
           dependenciesLineDashed,
           criticalPathLineColor,
           criticalPathLineWidth,
           timelineY,
           offsetTextTaskH,
           offsetDateBarV,
           offsetDateBarLeftH,
           offsetDateBarRightH,
           headerDatesCharSize,
           headerDatesCharFamily,
           headerDatesFormat,
           headerDatesCharStyle,
           headerDatesCharWeight,
           headerDatesCharColor,
           headerSpaceFromTimelineY,
           headerDatesSpace,
           todayDateLineColor,
           todayDateLineWidth,
           todayDateLineDashed, 
           showOnlyNotParents, showOnlyParents, 
           showOnlyNotDelay, showOnlyDelay, 
           showOnlyCritical, showOnlyNotCritical,
           showOnlyNotMilestone, showOnlyMilestone,
           showOnlyNotSelected, showOnlySelected,
           editMode} = options;

    const oneDayMs = 1000 * 60 * 60 * 24;
    let tasks = notFilteredTasks;
    // Filter parents if required and available
    if (showOnlyParents && !showOnlyNotParents) {
      tasks = tasks.filter(task => task.parent === true);
    } else if (showOnlyNotParents && !showOnlyParents) {
      tasks = tasks.filter(task => task.parent !== true);
    }     
    // Filter delays if required and available
    if (showOnlyDelay && !showOnlyNotDelay) {
      tasks = tasks.filter(task => task.delay === true);
    } else if (showOnlyNotDelay && !showOnlyDelay) {
      tasks = tasks.filter(task => task.delay !== true);
    }     
    // Filter critical if required and available
    if (showOnlyCritical && !showOnlyNotCritical) {
      tasks = tasks.filter(task => task.critical === true);
    } else if (showOnlyNotCritical && !showOnlyCritical) {
      tasks = tasks.filter(task => task.critical !== true);
    }     
    // Filter milestones if required and available
    if (showOnlyMilestone && !showOnlyNotMilestone) {
      tasks = tasks.filter(task => task.milestone === true);
    } else if (showOnlyNotMilestone && !showOnlyMilestone) {
      tasks = tasks.filter(task => task.milestone !== true);
    }     
    // Filter selected tasks if required and available
    if (showOnlySelected && !showOnlyNotSelected) {
      tasks = tasks.filter(task => isTaskInSelectedTasks(task.id));
    } else if (showOnlyNotSelected && !showOnlySelected) {
      tasks = tasks.filter(task => !isTaskInSelectedTasks(task.id));
    }

    if (!tasks || tasks.length === 0) {
      document.getElementById("svgContainer").innerHTML = "";
      return;
    }
    const svg = document.createElementNS(svgNS, "svg");

    const totalWidth = chartWidth + leftMargin + verticalShift + offsetZeroX + rightMargin;
    let lastXPosition = -Infinity;

    let chartHeight = 0;
    let bottomMargin = 0;
    tasks.forEach((task) => {
      // Set settings only for the selected tasks and changed event
      if (isTaskInSelectedTasks(task.id)) {
        if (!event || event.target.id == "csvInput") {
          // Behavior when the gantt chart creation is required refreshing the browser page, or
          // on the input CSV changes
          TasksSettings.setTaskSettings(task.id, options);
        } else if (event.target.id == "openProjectFromFile") {
          // Behavior when the gantt chart creation is required on open JSON file 
          // No action. All settings are those available in the JSON file
        } else { 
          // Default behaviour when the gantt chart creation is required by an "onclick" 
          // or "onchange" event in one of the input html control other than "csvInput" or "openProjectFromFile"
          const changedSetting = event.target;
          if (changedSetting.type == "checkbox") {
            TasksSettings.setTaskSettingByName(task.id, changedSetting.id, changedSetting.checked);
          } else {
            TasksSettings.setTaskSettingByName(task.id, changedSetting.id, changedSetting.value);
          }
        }
      }
      const barHeight = Number(TasksSettings.getTaskSettingByName(task.id, "barHeight"));
      const barSpace = Number(TasksSettings.getTaskSettingByName(task.id, "barSpace"));
      chartHeight = chartHeight + barHeight + barSpace;
      bottomMargin = barHeight + barSpace > bottomMargin ?
                     barHeight + barSpace :
                     bottomMargin;
    });
    
    const totalHeight = chartHeight + timelineY + bottomMargin + headerSpaceFromTimelineY;

    svg.setAttribute("id", "ganttChart");
    const viewBox = "0 0 " + totalWidth.toString() + " " + totalHeight.toString();
    svg.setAttribute("viewBox", viewBox);
    svg.setAttribute("preserveAspectRatio", "xMinYMin meet");

    let totalDays = (maxDate - minDate) / oneDayMs;
    if (totalDays == 0) totalDays = 1;

    // LEGEND at top 
    const legendGroup = document.createElementNS(svgNS, "g");
    legendGroup.setAttribute("class", "gantt-legend");
    svg.appendChild(legendGroup);
    const items = [
      { label: "not delay task, ", color: tasksCharColor, spaceX: 90},
      { label: "delay task, ", color: delayCharColor, spaceX: 80},
      { label: "actual % complete, ", color: percentCompleteColor, spaceX: 140},
      { label: "actual % not complete, ",    color: percentNotCompleteColor, spaceX: 160},
      { label: "actual parent % complete, ", color: parentPercentCompleteColor, spaceX: 175},
      { label: "actual parent % not complete, ", color: parentPercentNotCompleteColor, spaceX: 195},
      { label: "critical, ", color: criticalPathLineColor, spaceX: 75},
      { label: "milestone, ", color: percentNotCompleteColor, spaceX: 90},
      { label: "milestone complete", color: percentCompleteColor, spaceX: 0}
    ];
    const legendString = "Legend: ";
    const legendXLabel = leftMargin + 2;
    const legendX = legendXLabel + 70;
    const legendY = timelineY - headerSpaceFromTimelineY - headerDatesCharSize*2 - 15;
    const boxWidth = 20;
    const boxHeight = 10;
    const textOffset = 25;  // distance between box and label text
    // Legend label
    const legendLabel = document.createElementNS(svgNS, "text");
    legendLabel.setAttribute("x", legendXLabel);
    legendLabel.setAttribute("y", legendY + boxHeight - 1);
    legendLabel.setAttribute("fill", headerDatesCharColor);
    legendLabel.setAttribute("font-size", "12px");
    legendLabel.setAttribute("font-family", headerDatesCharFamily);
    legendLabel.textContent = "Legend: ";
    legendGroup.appendChild(legendLabel);
    // Legend items
    let x = legendX;
    items.forEach((item, i) => {
      const y = legendY;
      if (item.label !== "delay task, " 
          && item.label !== "not delay task, ") {
        // Draw colored rectangle for legend bars
        const rect = document.createElementNS(svgNS, "rect");
        rect.setAttribute("x", x);
        rect.setAttribute("y", y);
        rect.setAttribute("width", boxWidth);
        rect.setAttribute("height", boxHeight);
        rect.setAttribute("fill", item.color);
        rect.setAttribute("stroke", "#333");
        rect.setAttribute("stroke-width", "0.5");
        // Draw rhombus for milestones
        if (item.label == "milestone, " || item.label == "milestone complete") {
          const rhombusCenterX = x + boxWidth / 2;
          const rhombusCenterY = y + boxHeight / 2;        
          rect.setAttribute("width", boxWidth / 2);
          rect.setAttribute("height", boxWidth / 2);
          rect.setAttribute("transform", `rotate(45 ${rhombusCenterX} ${rhombusCenterY})`);
        }
        legendGroup.appendChild(rect);
        // Label for legend bars
        const label = document.createElementNS(svgNS, "text");
        label.setAttribute("x", x + textOffset);
        label.setAttribute("y", y + boxHeight - 1);
        label.setAttribute("fill", "#333");
        label.setAttribute("font-size", "12px");
        label.setAttribute("font-family", "sans-serif");
        label.textContent = item.label;
        legendGroup.appendChild(label);
      } 
      if (item.label == "not delay task, ") {
        // Label for tasks
        const taskLabel = document.createElementNS(svgNS, "text");
        taskLabel.setAttribute("x", x);
        taskLabel.setAttribute("y", y + boxHeight - 1);
        taskLabel.setAttribute("fill", item.color);
        taskLabel.setAttribute("font-size", "12px");
        taskLabel.setAttribute("font-family", tasksCharFamily);
        taskLabel.textContent = item.label;
        legendGroup.appendChild(taskLabel);
      }
      if (item.label == "delay task, ") {
        // Delay Label for tasks
        const delayLabel = document.createElementNS(svgNS, "text");
        delayLabel.setAttribute("x", x);
        delayLabel.setAttribute("y", y + boxHeight - 1);
        delayLabel.setAttribute("fill", item.color);
        delayLabel.setAttribute("font-size", "12px");
        delayLabel.setAttribute("font-family", delayCharFamily);
        delayLabel.textContent = item.label;
        legendGroup.appendChild(delayLabel);
      }
      x = x + item.spaceX;
    });

    // Timeline at the top
    uniqueStartDates.forEach(date => {
      const x = (leftMargin + verticalShift + offsetZeroX + ((date - minDate) + oneDayMs) / oneDayMs / totalDays * chartWidth);
      
      // Avoid overlapping date labels by checking lastXPosition
      if (x - lastXPosition > headerDatesSpace) { // Ensure at least headerDatesSpace space between dates
        const dateLabel = document.createElementNS(svgNS, "text");
        dateLabel.setAttribute("x", x);
        dateLabel.setAttribute("y", timelineY - headerSpaceFromTimelineY);
        dateLabel.setAttribute("font-size", headerDatesCharSize);
        dateLabel.setAttribute("font-family", headerDatesCharFamily);
        dateLabel.setAttribute("font-style", headerDatesCharStyle);
        dateLabel.setAttribute("font-weight", headerDatesCharWeight);
        dateLabel.setAttribute("fill", headerDatesCharColor);
        dateLabel.textContent = formatDate(date, headerDatesFormat);
        svg.appendChild(dateLabel);
        lastXPosition = x;
      }

      // Draw timeline vertical lines
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", x);
      line.setAttribute("y1", timelineY);
      line.setAttribute("x2", x);
      line.setAttribute("y2", totalHeight + timelineY);
      line.setAttribute("stroke", verticalLinesColor);
      line.setAttribute("stroke-width", verticalLinesWidth);
      svg.appendChild(line);
    });

    // Draw "Today" line if todayDate is within minDate and maxDate
    if (todayDate >= minDate && todayDate <= maxDate) {
      const xToday = (leftMargin + verticalShift + offsetZeroX + ((todayDate - minDate) + oneDayMs) / oneDayMs / totalDays * chartWidth);
      // Draw the today vertical line
      const todayLine = document.createElementNS(svgNS, "line");
      todayLine.setAttribute("x1", xToday);
      todayLine.setAttribute("y1", timelineY);
      todayLine.setAttribute("x2", xToday);
      todayLine.setAttribute("y2", totalHeight + timelineY);
      todayLine.setAttribute("stroke", todayDateLineColor); 
      todayLine.setAttribute("stroke-width", todayDateLineWidth);
      todayLine.setAttribute("stroke-dasharray", todayDateLineDashed);
      svg.appendChild(todayLine);
    }    

    // Tasks title
    const tasksTitle = document.createElementNS(svgNS, "text");
    tasksTitle.setAttribute("x", leftMargin + 2); // Align to the left of the vertical bar
    tasksTitle.setAttribute("y", timelineY - headerSpaceFromTimelineY); // Align to the top of the horizontal bar
    tasksTitle.setAttribute("font-size", headerDatesCharSize);
    tasksTitle.setAttribute("font-family", headerDatesCharFamily);
    tasksTitle.setAttribute("font-style", headerDatesCharStyle);
    tasksTitle.setAttribute("font-weight", headerDatesCharWeight);
    tasksTitle.setAttribute("fill", headerDatesCharColor);
    if (!editMode) {
      tasksTitle.textContent = `Id, Name`;
      if (tasksDetailedInfo_0) tasksTitle.textContent = tasksTitle.textContent + `, Actual %, Ideal %`;   

      if (tasksDetailedInfo_1) {
        const tasksTitleDetailed = document.createElementNS(svgNS, "text");
        tasksTitleDetailed.setAttribute("x", leftMargin + 2);
        tasksTitleDetailed.setAttribute("y", timelineY - headerSpaceFromTimelineY + tasksCharSize + 4);
        tasksTitleDetailed.setAttribute("font-size", headerDatesCharSize);
        tasksTitleDetailed.setAttribute("font-family", headerDatesCharFamily);
        tasksTitleDetailed.setAttribute("font-style", headerDatesCharStyle);
        tasksTitleDetailed.setAttribute("font-weight", headerDatesCharWeight);
        tasksTitleDetailed.setAttribute("fill", headerDatesCharColor);
        tasksTitleDetailed.textContent = `Duration, Elapsed, Total Float`;
        svg.appendChild(tasksTitleDetailed);
      }

      if (tasksDetailedInfo_2) {
        const tasksTitleDetailedMore = document.createElementNS(svgNS, "text");
        tasksTitleDetailedMore.setAttribute("x", leftMargin + 2);
        if (tasksDetailedInfo_1) tasksTitleDetailedMore.setAttribute("y", timelineY - headerSpaceFromTimelineY + (tasksCharSize + 4) * 2);
        else tasksTitleDetailedMore.setAttribute("y", timelineY - headerSpaceFromTimelineY + tasksCharSize + 4);
        tasksTitleDetailedMore.setAttribute("font-size", headerDatesCharSize);
        tasksTitleDetailedMore.setAttribute("font-family", headerDatesCharFamily);
        tasksTitleDetailedMore.setAttribute("font-style", headerDatesCharStyle);
        tasksTitleDetailedMore.setAttribute("font-weight", headerDatesCharWeight);
        tasksTitleDetailedMore.setAttribute("fill", headerDatesCharColor);
        tasksTitleDetailedMore.textContent = `Predecessors`;
        svg.appendChild(tasksTitleDetailedMore);
      }
    } else {
      tasksTitle.textContent = `Id, Name, Duration, % Complete, Predecessors, Parent`;
    }
    svg.appendChild(tasksTitle);

    // Horizontal timeline line
    const timeLine = document.createElementNS(svgNS, "line");
    timeLine.setAttribute("x1", leftMargin + verticalShift);
    timeLine.setAttribute("y1", timelineY);
    timeLine.setAttribute("x2", (leftMargin + verticalShift + offsetZeroX + ((maxDate - minDate) + oneDayMs) / oneDayMs / totalDays * chartWidth));
    timeLine.setAttribute("y2", timelineY);
    timeLine.setAttribute("stroke", axesColor);
    timeLine.setAttribute("stroke-width", axesWidth);
    svg.appendChild(timeLine);

    // Vertical bar at the start of the timeline
    const verticalBar = document.createElementNS(svgNS, "line");
    verticalBar.setAttribute("x1", leftMargin + verticalShift);
    verticalBar.setAttribute("y1", timelineY);
    verticalBar.setAttribute("x2", leftMargin + verticalShift);
    verticalBar.setAttribute("y2", totalHeight + timelineY);
    verticalBar.setAttribute("stroke", axesColor);
    verticalBar.setAttribute("stroke-width", axesWidth);
    svg.appendChild(verticalBar);

    // Task bars creation
    let y = timelineY;
    tasks.forEach((task) => {      
      // Set coordinates, width, and height of bars
      const totalWidth = (((task.endDate - task.startDate) + oneDayMs)/ oneDayMs) / totalDays * chartWidth;
      const widthComplete = totalWidth * (task.percentComplete / 100);
      const x = leftMargin + verticalShift + offsetZeroX + ((task.startDate - minDate) / oneDayMs) / totalDays * chartWidth;

      const taskSettings = TasksSettings.getTaskSettings(task.id);
      y = y + Number(taskSettings["barHeight"]) + Number(taskSettings["barSpace"]);

      // Draw the bar correlated to the current task
      drawBar(x, y, totalWidth, widthComplete, task, taskSettings);
      
      // For each task memorize coordinate x,y to use in dependecies drawing
      task.startX = x;
      task.startY = y + Number(taskSettings["barHeight"]) - 2;
      task.endX = x + totalWidth;
      task.endY = y + Number(taskSettings["barHeight"]) - 2;
      if (task.milestone) {
        task.startX = x + totalWidth - 2;
        task.startY = y + Number(taskSettings["barHeight"]) / 2 - 2;
        task.endX = x + totalWidth + Number(taskSettings["barHeight"]) / 2 - 2;
        task.endY = y + Number(taskSettings["barHeight"]) / 2 - 2;
      }  
    });

    //Draw dependencies
    drawDependencyPath(tasks, svg);

    document.getElementById("svgContainer").innerHTML = ""; // Clear previous SVGs
    document.getElementById("svgContainer").appendChild(svg);

    // Helper function to create task bars or milestone circles
    function drawBar(x, y, totalWidth, widthComplete, task, taskSettings) {
      //Task detailed information to show in Title elements of the SVG
      const taskDetails = (task.milestone ? "Milestone details:\n\n" : "Task details:\n\n")+
                          "id: "+task.id+"\n"+
                          "name: "+task.name+"\n"+
                          "duration: "+task.duration+"\n"+
                          "elapsed: "+task.elapsed+"\n"+
                          "percent complete: "+task.percentComplete+"\n"+
                          "ideal percent complete: "+task.idealPercentComplete+"\n"+
                          "earliest start date: "+formatDate(task.earliestStartDate,datesFormat)+"\n"+
                          "earliest finish date: "+formatDate(task.earliestFinishDate,datesFormat)+"\n"+
                          "latest start date: "+formatDate(task.latestStartDate, datesFormat)+"\n"+
                          "latest finish date: "+formatDate(task.latestFinishDate,datesFormat)+"\n"+
                          "start date: "+formatDate(task.startDate,datesFormat)+"\n"+
                          "end date: "+formatDate(task.endDate,datesFormat)+"\n"+
                          "predecessors: "+task.predecessors.map(p => String(p.id) + " " + String(p.dependencyType) + " " + String(p.leadLag))+"\n"+
                          "total float: "+task.totalFloat+"\n"+
                          "is critical: "+task.critical+"\n"+
                          "is delay: "+task.delay+"\n"+
                          "is milestone: "+task.milestone+"\n"+
                          "is parent: "+task.parent+"\n"+
                          "parent Id: "+task.parentId+"\n"+
                          "depth: "+task.depth;

      if (task.milestone) {
        // Draw milestone as a rhombus
        const milestoneRhombus = document.createElementNS(svgNS, "rect");
        const rhombusWidth = Number(taskSettings["barHeight"]) / 2;
        const rhombusHeight = Number(taskSettings["barHeight"]) / 2;
        const rhombusCenterX = x + totalWidth;
        const rhombusCenterY = y;
        milestoneRhombus.setAttribute("x", rhombusCenterX);
        milestoneRhombus.setAttribute("y", rhombusCenterY);
        milestoneRhombus.setAttribute("width", rhombusWidth);
        milestoneRhombus.setAttribute("height", rhombusHeight);
        task.percentComplete == 100 ? 
           milestoneRhombus.setAttribute("fill", taskSettings["percentCompleteColor"]):   
           milestoneRhombus.setAttribute("fill", taskSettings["percentNotCompleteColor"]);
        milestoneRhombus.setAttribute("transform", `rotate(45 ${rhombusCenterX} ${rhombusCenterY})`);

        // Milestone data showed as Title of SVG circle on mouse over
        const titleMilestone = document.createElementNS(svgNS, "title");
        titleMilestone.textContent = taskDetails; 
        milestoneRhombus.appendChild(titleMilestone);

        svg.appendChild(milestoneRhombus);

        // Add end date to the right of the milestone
        const endText = document.createElementNS(svgNS, "text");
        endText.setAttribute("x", x + Number(taskSettings["offsetDateBarRightH"]) + rhombusWidth + totalWidth);
        endText.setAttribute("y", y + Number(taskSettings["offsetDateBarV"]) - rhombusHeight);
        endText.setAttribute("font-size", taskSettings["datesCharSize"]);
        endText.setAttribute("font-family", taskSettings["datesCharFamily"]);
        endText.setAttribute("font-style", taskSettings["datesCharStyle"]);
        endText.setAttribute("font-weight", taskSettings["datesCharWeight"]);
        endText.setAttribute("fill", taskSettings["datesCharColor"]);
        endText.textContent = formatDate(task.endDate,taskSettings["datesFormat"]);
        svg.appendChild(endText);

      } else {
        // Bar whitout percent complete portion
        const notCompleteRect = document.createElementNS(svgNS, "rect");
        notCompleteRect.setAttribute("x", x);
        notCompleteRect.setAttribute("y", y);
        notCompleteRect.setAttribute("width", totalWidth);
        notCompleteRect.setAttribute("height", taskSettings["barHeight"]);
        notCompleteRect.setAttribute("fill", taskSettings["percentNotCompleteColor"]);
        notCompleteRect.setAttribute("stroke", taskSettings["strokeColor"]); 
        notCompleteRect.setAttribute("stroke-width", taskSettings["barBorderThickness"]); 
        notCompleteRect.setAttribute("rx", taskSettings["barAngles"]); 
        notCompleteRect.setAttribute("ry", taskSettings["barAngles"]);
        if (task.parent) {
          notCompleteRect.setAttribute("fill", taskSettings["parentPercentNotCompleteColor"]);
          notCompleteRect.setAttribute("rx", taskSettings["parentBarAngles"]);
          notCompleteRect.setAttribute("ry", taskSettings["parentBarAngles"]); 
        }

        // Task data showed as Title of bar SVG rect on mouse over
        const titleNotCompleteRect = document.createElementNS(svgNS, "title");
        titleNotCompleteRect.textContent = taskDetails; 
        notCompleteRect.appendChild(titleNotCompleteRect);

        svg.appendChild(notCompleteRect);

        // Portion for percent complete
        const completeRect = document.createElementNS(svgNS, "rect");
        completeRect.setAttribute("x", x);
        completeRect.setAttribute("y", y);
        completeRect.setAttribute("width", widthComplete);
        completeRect.setAttribute("height", taskSettings["barHeight"]);
        completeRect.setAttribute("fill", taskSettings["percentCompleteColor"]);
        completeRect.setAttribute("stroke", taskSettings["strokeColor"]); 
        completeRect.setAttribute("stroke-width", taskSettings["barBorderThickness"]); 
        completeRect.setAttribute("rx", taskSettings["barAngles"]); 
        completeRect.setAttribute("ry", taskSettings["barAngles"]);
        if (task.parent) {
          completeRect.setAttribute("fill", taskSettings["parentPercentCompleteColor"]);
          completeRect.setAttribute("rx", taskSettings["parentBarAngles"]); 
          completeRect.setAttribute("ry", taskSettings["parentBarAngles"]);
        }
 
        // Task data showed as Title of bar SVG rect on mouse over
        const titleCompleteRect = document.createElementNS(svgNS, "title");
        titleCompleteRect.textContent = taskDetails; 
        completeRect.appendChild(titleCompleteRect);

        svg.appendChild(completeRect);

        // Critical path
        if (task.critical) {
          const criticalRect = document.createElementNS(svgNS, "rect");
          criticalRect.setAttribute("x", x);
          criticalRect.setAttribute("y", y + (Number(taskSettings["barHeight"]) - Number(taskSettings["criticalPathLineWidth"]))/2);
          criticalRect.setAttribute("width", totalWidth);
          criticalRect.setAttribute("height", taskSettings["criticalPathLineWidth"]);
          criticalRect.setAttribute("fill", taskSettings["criticalPathLineColor"]);
          criticalRect.setAttribute("rx", taskSettings["barAngles"]); 
          criticalRect.setAttribute("ry", taskSettings["barAngles"]); 

          // Task data showed as Title of critical SVG bar on mouse over
          const titleCriticalRect = document.createElementNS(svgNS, "title");
          titleCriticalRect.textContent = taskDetails; 
          criticalRect.appendChild(titleCriticalRect);

          svg.appendChild(criticalRect);
        }

        // Task start and end date labels
        const startText = document.createElementNS(svgNS, "text");
        startText.setAttribute("x", x - Number(taskSettings["offsetDateBarLeftH"])); 
        startText.setAttribute("y", y + Number(taskSettings["offsetDateBarV"]));
        startText.setAttribute("font-size", taskSettings["datesCharSize"]);
        startText.setAttribute("font-family", taskSettings["datesCharFamily"]);
        startText.setAttribute("font-style", taskSettings["datesCharStyle"]);
        startText.setAttribute("font-weight", taskSettings["datesCharWeight"]);
        startText.setAttribute("fill", taskSettings["datesCharColor"]);
        startText.textContent = formatDate(task.startDate, taskSettings["datesFormat"]);
        svg.appendChild(startText);

        const endText = document.createElementNS(svgNS, "text");
        endText.setAttribute("x", x + totalWidth + Number(taskSettings["offsetDateBarRightH"]));
        endText.setAttribute("y", y + Number(taskSettings["offsetDateBarV"]));
        endText.setAttribute("font-size", taskSettings["datesCharSize"]);
        endText.setAttribute("font-family", taskSettings["datesCharFamily"]);
        endText.setAttribute("font-style", taskSettings["datesCharStyle"]);
        endText.setAttribute("font-weight", taskSettings["datesCharWeight"]);
        endText.setAttribute("fill", taskSettings["datesCharColor"]);
        endText.textContent = formatDate(task.endDate, taskSettings["datesFormat"]);
        svg.appendChild(endText);
      }

      // Add primary task info to the left of the vertical bar
      const nameText = document.createElementNS(svgNS, "text");

      // Settings used in edit mode
      nameText.setAttribute("class", "task-label");
      nameText.setAttribute("data-task-id", task.id);
      //

      nameText.setAttribute("x", leftMargin + 2 + Number(taskSettings["offsetTextTaskH"])*(task.depth));
      nameText.setAttribute("y", y + 2 + Number(taskSettings["offsetDateBarV"]) - Number(taskSettings["tasksDetailedInfo_1"] && taskSettings["tasksDetailedInfo_2"]) * Number(taskSettings["tasksCharSize"]));
      nameText.setAttribute("font-size", taskSettings["tasksCharSize"]);
      nameText.setAttribute("font-family", taskSettings["tasksCharFamily"]);
      nameText.setAttribute("font-style", taskSettings["tasksCharStyle"]);
      nameText.setAttribute("font-weight", taskSettings["tasksCharWeight"]);
      nameText.setAttribute("fill", taskSettings["tasksCharColor"]);
      if (task.parent) {
        nameText.setAttribute("font-size", taskSettings["parentsCharSize"]);
        nameText.setAttribute("font-family", taskSettings["parentsCharFamily"]);
        nameText.setAttribute("font-style", taskSettings["parentsCharStyle"]);
        nameText.setAttribute("font-weight", taskSettings["parentsCharWeight"]);
        nameText.setAttribute("fill", taskSettings["parentsCharColor"]);
      }
      if (task.delay) {
        nameText.setAttribute("fill", taskSettings["delayCharColor"]);
        if (!task.parent) {
          nameText.setAttribute("font-size", taskSettings["delayCharSize"]);
          nameText.setAttribute("font-family", taskSettings["delayCharFamily"]);
          nameText.setAttribute("font-style", taskSettings["delayCharStyle"]);
        }
      }
      const truncatedTaskName = (String(task.name).length < Number(taskSettings["tasksTruncate"]) && String(task.name).length>0) ? 
                                 String(task.name) : 
                                (String(task.name).slice(0, Number(taskSettings["tasksTruncate"])) + "...");
      nameText.textContent = `${task.id}, ${truncatedTaskName}`;
      if (taskSettings["tasksDetailedInfo_0"]) nameText.textContent = nameText.textContent + `, ${Math.round(task.percentComplete)}%, ${Math.round(task.idealPercentComplete)}%`;

      // Task data showed as Title of tasks SVG text on mouse over
      const titleNameText = document.createElementNS(svgNS, "title");
      titleNameText.textContent = taskDetails; 
      nameText.appendChild(titleNameText);
      svg.appendChild(nameText);

      //Add detailed Task info in the line below if needed
      if (taskSettings["tasksDetailedInfo_1"] && !editMode) {
         const detailedText = document.createElementNS(svgNS, "text");
         detailedText.setAttribute("x", leftMargin + 16 + Number(taskSettings["offsetTextTaskH"])*(task.depth));
         detailedText.setAttribute("y", y + 2 + Number(taskSettings["offsetDateBarV"]) + Number(taskSettings["tasksCharSize"]) - Number(taskSettings["tasksDetailedInfo_2"]) * Number(taskSettings["tasksCharSize"])); //Space for the line below
         detailedText.setAttribute("font-size", taskSettings["tasksCharSize"]);
         detailedText.setAttribute("font-family", taskSettings["tasksCharFamily"]);
         detailedText.setAttribute("font-style", taskSettings["tasksCharStyle"]);
         detailedText.setAttribute("font-weight", taskSettings["tasksCharWeight"]);
         detailedText.setAttribute("fill", taskSettings["tasksCharColor"]);
         if (task.parent) {
           detailedText.setAttribute("font-size", taskSettings["parentsCharSize"]);
           detailedText.setAttribute("font-family", taskSettings["parentsCharFamily"]);
           detailedText.setAttribute("font-style", taskSettings["parentsCharStyle"]);
           detailedText.setAttribute("font-weight", taskSettings["parentsCharWeight"]);
           detailedText.setAttribute("fill", taskSettings["parentsCharColor"]);
         }
         if (task.delay) {
           detailedText.setAttribute("fill", taskSettings["delayCharColor"]);
           if (!task.parent) {
             detailedText.setAttribute("font-size", taskSettings["delayCharSize"]);
             detailedText.setAttribute("font-family", taskSettings["delayCharFamily"]);
             detailedText.setAttribute("font-style", taskSettings["delayCharStyle"]);
           }
         }
         detailedText.textContent = `${task.duration}, ${task.elapsed}, ${task.totalFloat}`;
         const titleNameText = document.createElementNS(svgNS, "title");
         titleNameText.textContent = taskDetails; 
         detailedText.appendChild(titleNameText);
         svg.appendChild(detailedText);
      }
      
      //Add detailed Task info in the second line below if needed
      if (taskSettings["tasksDetailedInfo_2"] && !editMode) {
         const detailedTextMore = document.createElementNS(svgNS, "text");
         detailedTextMore.setAttribute("x", leftMargin + 16 + Number(taskSettings["offsetTextTaskH"])*(task.depth));
         detailedTextMore.setAttribute("y", y + 4 + Number(taskSettings["offsetDateBarV"]) + Number(taskSettings["tasksCharSize"]));
         detailedTextMore.setAttribute("font-size", taskSettings["tasksCharSize"]);
         detailedTextMore.setAttribute("font-family", taskSettings["tasksCharFamily"]);
         detailedTextMore.setAttribute("font-style", taskSettings["tasksCharStyle"]);
         detailedTextMore.setAttribute("font-weight", taskSettings["tasksCharWeight"]);
         detailedTextMore.setAttribute("fill", taskSettings["tasksCharColor"]);
         if (task.parent) {
           detailedTextMore.setAttribute("font-size", taskSettings["parentsCharSize"]);
           detailedTextMore.setAttribute("font-family", taskSettings["parentsCharFamily"]);
           detailedTextMore.setAttribute("font-style", taskSettings["parentsCharStyle"]);
           detailedTextMore.setAttribute("font-weight", taskSettings["parentsCharWeight"]);
           detailedTextMore.setAttribute("fill", taskSettings["parentsCharColor"]);
         }
         if (task.delay) {
           detailedTextMore.setAttribute("fill", taskSettings["delayCharColor"]);
           if (!task.parent) {
             detailedTextMore.setAttribute("font-size", taskSettings["delayCharSize"]);
             detailedTextMore.setAttribute("font-family", taskSettings["delayCharFamily"]);
             detailedTextMore.setAttribute("font-style", taskSettings["delayCharStyle"]);
           }
         }
         detailedTextMore.textContent = ' ';
         task.predecessors.
           forEach(p => { 
            detailedTextMore.textContent = detailedTextMore.textContent + `${p.id}${p.dependencyType} ${p.leadLag}, `;
         });
         detailedTextMore.textContent = detailedTextMore.textContent.replace(/, $/, ''); //remove the final comma
         detailedTextMore.textContent = (detailedTextMore.textContent.length < Number(taskSettings["tasksTruncate"]) && detailedTextMore.textContent.length > 0) ?
                                         detailedTextMore.textContent : 
                                        (detailedTextMore.textContent.slice(0, Number(taskSettings["tasksTruncate"])) + "...");
         const titleNameTextMore = document.createElementNS(svgNS, "title");
         titleNameTextMore.textContent = taskDetails; 
         detailedTextMore.appendChild(titleNameTextMore);
         svg.appendChild(detailedTextMore);
      }

      // Horizontal line separator
      const lineSeparator = document.createElementNS(svgNS, "line");
      lineSeparator.setAttribute("x1", leftMargin + 2);
      lineSeparator.setAttribute("y1", y + Number(taskSettings["barHeight"]) + 8);
      lineSeparator.setAttribute("x2", (leftMargin + verticalShift + offsetZeroX + ((maxDate - minDate) + oneDayMs)/ oneDayMs / totalDays * chartWidth));
      lineSeparator.setAttribute("y2", y + Number(taskSettings["barHeight"]) + 8);
      lineSeparator.setAttribute("stroke", taskSettings["horizontalSeparatorsColor"]);
      lineSeparator.setAttribute("stroke-width", taskSettings["horizontalSeparatorsWidth"]);
      svg.appendChild(lineSeparator);
    } // End drawBar(..)

    // Helper function to create dependencies of a task bar
    function drawDependencyPath(tasks, svg) {
      //Draw dependencies for each task with dependecies in tasks
      tasks.forEach((task, index) => {
        const isDependent = task.predecessors.length != 0;
        if (isDependent) {
          task.predecessors.forEach(dep => {
            const fromTask = tasks.find(t => t.id === dep.id);
            const toTask = task;
            if (fromTask && toTask) {
              // Draw dependency line
              const path = document.createElementNS(svgNS, "path");
              // Set x, and y values of the dependecy lines on the base of the type of dependency
              fromX = 0;
              fromY = 0;
              toX = 0;
              toY = 0;
              fromX_offsetDateBarRightH = 0;
              fromY_barHeight = 0;
              fromX_offsetDateBarLeftH = 0;
              toX_offsetDateBarLeftH = 0;
              toX_offsetDateBarRightH = 0;
              toX_offsetDateBarLeftH = 0;
              if (dep.dependencyType==="FS" || dep.dependencyType===null) {
                fromX = fromTask.endX;
                fromY = fromTask.endY;
                toX = toTask.startX;
                toY = toTask.startY;
                fromX_offsetDateBarRightH = Number(TasksSettings.getTaskSettingByName(fromTask.id, "offsetDateBarRightH"));
                fromY_barHeight = Number(TasksSettings.getTaskSettingByName(fromTask.id, "barHeight"));
                toX_offsetDateBarLeftH = Number(TasksSettings.getTaskSettingByName(toTask.id, "offsetDateBarLeftH"));
                // Define the dependency line path FS type
                path.setAttribute("d", `M ${fromX} ${fromY} H ${fromX + fromX_offsetDateBarRightH} V ${fromY + (fromY_barHeight/2)} H ${toX - toX_offsetDateBarLeftH - 2} V ${toY} H ${toX}`);
              } else if (dep.dependencyType==="FF") {
                fromX = fromTask.endX;
                fromY = fromTask.endY;
                toX = toTask.endX;
                toY = toTask.endY;
                toX_offsetDateBarRightH = Number(TasksSettings.getTaskSettingByName(toTask.id, "offsetDateBarRightH"));
                toX_offsetDateBarLeftH = Number(TasksSettings.getTaskSettingByName(toTask.id, "offsetDateBarLeftH"));
                // Define the dependency line path FF type
                path.setAttribute("d", `M ${fromX} ${fromY} H ${toX + toX_offsetDateBarRightH + toX_offsetDateBarLeftH} V ${toY} H ${toX}`);
              } else if (dep.dependencyType==="SF") {
                fromX = fromTask.startX;
                fromY = fromTask.startY;
                toX = toTask.endX;
                toY = toTask.endY;   
                fromX_offsetDateBarLeftH = Number(TasksSettings.getTaskSettingByName(fromTask.id, "offsetDateBarLeftH"));
                fromY_barHeight = Number(TasksSettings.getTaskSettingByName(fromTask.id, "barHeight"));
                toX_offsetDateBarRightH = Number(TasksSettings.getTaskSettingByName(toTask.id, "offsetDateBarRightH"));
                toX_offsetDateBarLeftH = Number(TasksSettings.getTaskSettingByName(toTask.id, "offsetDateBarLeftH"));
                // Define the dependency line path SF type
                path.setAttribute("d", `M ${fromX} ${fromY} H ${fromX - fromX_offsetDateBarLeftH -2} V ${fromY + (fromY_barHeight/2)} H ${toX + toX_offsetDateBarRightH + toX_offsetDateBarLeftH} V ${toY} H ${toX}`);
              } else if (dep.dependencyType==="SS"){
                fromX = fromTask.startX;
                fromY = fromTask.startY;
                toX = toTask.startX;
                toY = toTask.startY;
                fromX_offsetDateBarLeftH = Number(TasksSettings.getTaskSettingByName(fromTask.id, "offsetDateBarLeftH"));
                // Define the dependency line path SS type
                path.setAttribute("d", `M ${fromX} ${fromY} H ${fromX - fromX_offsetDateBarLeftH - 2} V ${toY} H ${toX}`);
              }
              //Draw dependency line
              path.setAttribute("stroke", TasksSettings.getTaskSettingByName(toTask.id, "dependenciesLineColor"));
              path.setAttribute("stroke-width", TasksSettings.getTaskSettingByName(toTask.id, "dependenciesLineWidth"));
              path.setAttribute("stroke-dasharray", TasksSettings.getTaskSettingByName(toTask.id, "dependenciesLineDashed"));
              path.setAttribute("fill", "none");
              // Draw marker arrow
              const marker = document.createElementNS(svgNS, "marker");
              const markerId = `arrow-${toTask.id}`
              marker.setAttribute("id", markerId);
              marker.setAttribute("markerWidth", "10");
              marker.setAttribute("markerHeight", "10");
              marker.setAttribute("refX", "10");
              marker.setAttribute("refY", "5");
              marker.setAttribute("orient", "auto-start-reverse");
              marker.setAttribute("markerUnits", "strokeWidth");
              const arrow = document.createElementNS(svgNS, "path");
              arrow.setAttribute("d", "M0,0 L10,5 L0,10 L4,5 Z");
              arrow.setAttribute("fill", TasksSettings.getTaskSettingByName(toTask.id, "dependenciesLineColor"));
              marker.appendChild(arrow);
              svg.appendChild(marker);
              path.setAttribute("marker-end", `url(#${markerId})`);
              svg.appendChild(path);
            }  
          })    
        }
      })
    } // End drawDependencyPath(..)
  } // End createGanttChart(..)

  // Global object to store and retrieve tasks/bars Settings
  const TasksSettings = {
    settings: {},
    setTaskSettings(taskId, settings) {
      if (!this.settings[taskId]) {
        this.settings[taskId] = {};
      }
      Object.entries(settings).forEach(([key, value]) => {
        this.settings[taskId][key] = value;
      });
    },
    setTaskSettingByName(taskId, settingName, value) {
      if (!this.settings[taskId]) {
        this.settings[taskId] = {};
      }
      this.settings[taskId][settingName] = value;
    },
    getTaskSettingByName(taskId, settingName) {
      if (this.settings[taskId]) {
        return this.settings[taskId][settingName] || null;
      }
      return null;
    },
    getTaskSettingsByNames(taskId, settingNames = []) {
      const result = {};
      if (this.settings[taskId]) {
        settingNames.forEach(name => {
          if (name in this.settings[taskId]) {
            result[name] = this.settings[taskId][name];
          }
        });
      }
      return result;
    },
    getTaskSettings(taskId) {
      const result = {};
      const taskSettings = this.settings[taskId];
      if (taskSettings) {
        Object.keys(taskSettings).forEach(name => {
          result[name] = taskSettings[name];
        });
      }
      return result;
    },
    getAllSettings() {
      return this.settings;
    }
  };

  // Global configuration object to store non-working dates
  window.NonWorkingDatesConfig = {
      config: null,
      setConfig: function(config) {
          this.config = config;
      },
      getConfig: function() {
          return this.config;
      }
  };
      
  // Global function to retrieve non-working dates configuration
  function getNonWorkingDatesConfig() {
      const currentConfig = window.NonWorkingDatesConfig.getConfig();
      // If no configuration exists, return a default configuration
      if (!currentConfig) {
          return {
              saturdayNonWorking: true,
              sundayNonWorking: true,
              nonWorkingPeriods: [],
              nonWorkingDates: []
          };
      }
      // Otherwise, return the existing configuration
      return currentConfig;
  }

  // Global function to set non-working dates configuration
  function setNonWorkingDatesConfig(nonWorkingConfig) {
    window.NonWorkingDatesConfig.setConfig(nonWorkingConfig);
  }

  // Global function to create the non-working dates popup user interface
  function createNonWorkingDatesPopup() {
      //retrieve possible non-working dates existing configurations
      const existingNonWorkingDatesConfig = getNonWorkingDatesConfig();

      // Create popup overlay
      const overlay = document.createElement('div');
      overlay.classList.add('popup-overlay');

      // Create popup container
      const popup = document.createElement('div');
      popup.classList.add('popup-container');

      // Checkbox section
      const checkboxSection = document.createElement('div');
      checkboxSection.classList.add('checkbox-section');

      // Saturday checkbox
      const saturdayCheckbox = document.createElement('input');
      saturdayCheckbox.type = 'checkbox';
      saturdayCheckbox.id = 'saturday-non-working';
      saturdayCheckbox.checked = existingNonWorkingDatesConfig.saturdayNonWorking;

      const saturdayLabel = document.createElement('label');
      saturdayLabel.htmlFor = 'saturday-non-working';
      saturdayLabel.appendChild(document.createTextNode('Saturday non-working'));

      checkboxSection.appendChild(saturdayCheckbox);
      checkboxSection.appendChild(saturdayLabel);
      checkboxSection.appendChild(document.createElement('br'));

      // Sunday checkbox
      const sundayCheckbox = document.createElement('input');
      sundayCheckbox.type = 'checkbox';
      sundayCheckbox.id = 'sunday-non-working';
      sundayCheckbox.checked = existingNonWorkingDatesConfig.sundayNonWorking;

      const sundayLabel = document.createElement('label');
      sundayLabel.htmlFor = 'sunday-non-working';
      sundayLabel.appendChild(document.createTextNode('Sunday non-working'));

      checkboxSection.appendChild(sundayCheckbox);
      checkboxSection.appendChild(sundayLabel);

      popup.appendChild(checkboxSection);

      // Date ranges label
      const dateRangesLabel = document.createElement('label');
      dateRangesLabel.htmlFor = 'date-range-label';
      dateRangesLabel.appendChild(document.createTextNode('Non working periods:'));
      dateRangesLabel.appendChild(document.createElement('br'));
      dateRangesLabel.appendChild(document.createElement('br'));

      // Date ranges container
      const dateRangesContainer = document.createElement('div');
      dateRangesContainer.id = 'date-ranges-container';

      // Initial date range row
      const createDateRangeRow = (fromDate = null, toDate = null) => {
          const row = document.createElement('div');
          row.classList.add('date-range-row');

          const fromDateInput = document.createElement('input');
          fromDateInput.type = 'date';
          fromDateInput.placeholder = 'Non-Working From';
          //fromDateInput.valueAsDate = fromDate;
          fromDateInput.value = fromDate;

          const toDateInput = document.createElement('input');
          toDateInput.type = 'date';
          toDateInput.placeholder = 'Non-Working To';
          //toDateInput.valueAsDate = toDate;
          toDateInput.value = toDate;

          row.appendChild(fromDateInput);
          row.appendChild(toDateInput);

          return row;
      };

      // Initial date ranges
      if(existingNonWorkingDatesConfig.nonWorkingPeriods.length === 0) {
        const initialDateRange = createDateRangeRow();
        dateRangesContainer.appendChild(initialDateRange);
      // Existing date ranges  
      } else {
        existingNonWorkingDatesConfig.nonWorkingPeriods
          .forEach(nonWorkingPeriod => {
            const dateRange = createDateRangeRow(nonWorkingPeriod.fromDate, nonWorkingPeriod.toDate);
            dateRangesContainer.appendChild(dateRange);
        });
      }

      // Add "+" button
      const addButton = document.createElement('button');
      addButton.textContent = '+';
      addButton.addEventListener('click', () => {
          const newDateRange = createDateRangeRow();
          dateRangesContainer.appendChild(newDateRange);
      });

      const addButtonContainer = document.createElement('div');
      addButtonContainer.style.textAlign = 'right';
      addButtonContainer.appendChild(addButton);

      popup.appendChild(dateRangesLabel);
      popup.appendChild(dateRangesContainer);
      popup.appendChild(addButtonContainer);

      // Popup controls
      const controlsSection = document.createElement('div');
      controlsSection.classList.add('popup-controls');

      // Clear button
      const clearButton = document.createElement('button');
      clearButton.textContent = 'Clear';
      clearButton.addEventListener('click', () => {
          // Reset checkboxes
          saturdayCheckbox.checked = true;
          sundayCheckbox.checked = true;

          // Remove all date ranges except the first
          while (dateRangesContainer.children.length > 1) {
              dateRangesContainer.removeChild(dateRangesContainer.lastChild);
          }

          // Clear date inputs
          const dateInputs = dateRangesContainer.querySelectorAll('input[type="date"]');
          dateInputs.forEach(input => input.value = '');
      });

      // OK button
      const okButton = document.createElement('button');
      okButton.textContent = 'OK';
      okButton.addEventListener('click', () => {
          const nonWorkingConfig = getNonWorkingDates();
          // Store in global configuration object
          window.NonWorkingDatesConfig.setConfig(nonWorkingConfig);
          document.body.removeChild(overlay);
          generateGanttChart();
          return nonWorkingConfig;
      });

      controlsSection.appendChild(clearButton);
      controlsSection.appendChild(okButton);

      popup.appendChild(controlsSection);
      overlay.appendChild(popup);
      document.body.appendChild(overlay);

      // Helper function to get non-working dates configuration
      function getNonWorkingDates() {
          // Prepare the return object
          const nonWorkingConfig = {
              saturdayNonWorking: saturdayCheckbox.checked,
              sundayNonWorking: sundayCheckbox.checked,
              nonWorkingPeriods: [],
              nonWorkingDates: []
          };
          // Add date ranges
          const dateRanges = dateRangesContainer.querySelectorAll('.date-range-row');
          let i = 0;
          dateRanges.forEach(row => {
              const fromInput = row.querySelector('input[type="date"]:first-child');
              const toInput = row.querySelector('input[type="date"]:last-child');
              nonWorkingConfig.nonWorkingPeriods[i] = {fromDate: new Date(fromInput.value), toDate: new Date(toInput.value)};
              if (fromInput.value && toInput.value)
                nonWorkingConfig.nonWorkingPeriods[i] = 
                  {fromDate: (new Date(fromInput.value)).toISOString().split('T')[0], 
                   toDate: (new Date(toInput.value)).toISOString().split('T')[0]};
              i++;
              if (fromInput.value && toInput.value) {
                  const fromDate = new Date(fromInput.value);
                  const toDate = new Date(toInput.value);
                  // Ensure from date is before or equal to to date
                  if (fromDate <= toDate) {
                      for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
                          const currentDate = new Date(d);
                          const dateString = currentDate.toISOString().split('T')[0];
                          // Check weekend conditions
                          if ((nonWorkingConfig.saturdayNonWorking && currentDate.getDay() === 6) ||
                              (nonWorkingConfig.sundayNonWorking && currentDate.getDay() === 0) ||
                              // Include other dates in the range
                              (currentDate.getDay() > 0 && currentDate.getDay() < 6)) {
                              // Avoid duplicates
                              if (!nonWorkingConfig.nonWorkingDates.includes(dateString)) {
                                  nonWorkingConfig.nonWorkingDates.push(dateString);
                              }
                          }
                      }
                  }
              }
          });
          // Sort the dates
          nonWorkingConfig.nonWorkingDates.sort();
          return nonWorkingConfig;
        }
        // Return object with method to get non-working dates
        return {getNonWorkingDates: getNonWorkingDates};
  }

  // Global function to open popup for non working dates
  function openNonWorkingDatesPopup() {
      window.nonWorkingDatesSelector = createNonWorkingDatesPopup();
  }

  async function saveProjectToFile() {
    try {
        const settings = {};
        // Get all input elements within the #options div
        const optionsDiv = document.getElementById("inputArea");
        const inputs = optionsDiv.querySelectorAll("input, select, textarea");
        // Iterate through inputs to collect their id and value
        inputs.forEach(input => {
          if (input.type === "checkbox") {
            settings[input.id] = input.checked; // Save boolean for checkboxes
          } else if (input.type === "number") {
            settings[input.id] = parseFloat(input.value); // Save number for number inputs
          } else if (input.tagName.toLowerCase() === "select") {
              if (input.multiple) {
                // For multi-select, save an array of selected values
                const selectedOptions = Array.from(input.options)
                      .filter(option => option.selected)
                      .map(option => option.value);
                settings[input.id] = selectedOptions;
              } else {
                settings[input.id] = input.value; // Save the selected value for single-select
              }                
          } else {
            settings[input.id] = input.value; // Save string for text, date inputs
          }
        });
        // Add non-working dates configuration
        const nonWorkingConfig = getNonWorkingDatesConfig();
        settings.nonWorkingConfig = nonWorkingConfig;
        // Add tasks settings object
        settings.tasksSettings = TasksSettings.getAllSettings();
        // Convert settings to JSON
        const settingsJSON = JSON.stringify(settings, null, 2);
        // Prompt the user to select a file name and folder
        const fileHandle = await window.showSaveFilePicker({
            suggestedName: "project-settings.json",
            types: [
                {
                    description: "JSON Files",
                    accept: { "application/json": [".json"] }
                }
            ]
        });
        // Create a writable stream and write the JSON to the file
        const writableStream = await fileHandle.createWritable();
        await writableStream.write(settingsJSON);
        await writableStream.close();
        alertWithConfirmation("Project saved successfully!");
    } catch (error) {
        console.error("Error saving settings:", error);
        alertWithConfirmation("Failed to save project. Make sure your browser supports the File System Access API.");
    }
  }

  async function saveTasksAsCSV(inputString){
    try {
      // Prompt the user to select a file name and folder
      const fileHandle = await window.showSaveFilePicker({
      suggestedName: "project-tasks.txt.csv",
        types: [{
                 description: "CSV Files",
                 accept: { "application/csv": [".csv"] }
               }]
      });
      // Create a writable stream and write the CSV to the file
      const writableStream = await fileHandle.createWritable();
      await writableStream.write(inputString);
      await writableStream.close();
      alertWithConfirmation("File saved successfully!");
      } catch (error) {
        console.error("Error saving CSV file:", error);
        alertWithConfirmation("Failed to save file. Make sure your browser supports the File System Access API.");
    }
  } 

  function openProjectFromFile(eventButton) {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.json'; // Only allow JSON files
    fileInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      try {
        const fileContent = await file.text(); // Read file content as text
        const settings = JSON.parse(fileContent); // Parse the JSON content
        const optionsDiv = document.getElementById("inputArea");
        const inputs = optionsDiv.querySelectorAll("input, select, textarea");
        inputs.forEach(input => {
            if (settings.hasOwnProperty(input.id)) {
                if (input.type === "checkbox") {
                    input.checked = settings[input.id]; // Load boolean for checkboxes
                } else if (input.type === "number") {
                    input.value = parseFloat(settings[input.id]); // Load number for number inputs
                } else if (input.tagName.toLowerCase() === "select") {
                  const selectValue = settings[input.id];                  
                  // Multi-select "taskIdSelector" dropdown re-create options and temporary assignement to false
                  if (input.name = "taskIdSelector" && Array.isArray(selectValue)) {
                    const taskIdSelector = document.getElementById("taskIdSelector");
                    while (taskIdSelector.options.length > 0) {
                      taskIdSelector.remove(0);
                    }
                    const tasksSettings = settings.tasksSettings;
                    const taskIds = Object.keys(tasksSettings);
                    taskIds.forEach(taskId => {
                      const optionControl = document.createElement("option");
                      optionControl.value = taskId;
                      optionControl.textContent = taskId;
                      optionControl.id = "task.id" + taskId;
                      optionControl.selected = false;
                      taskIdSelector.appendChild(optionControl);
                    });
                    // Multi-select dropdown
                  } else if (input.multiple && Array.isArray(selectValue)) {
                    Array.from(input.options).forEach(option => {
                          option.selected = selectValue.includes(option.value);
                    });
                  } else {
                    // Single-select dropdown
                    const matchingOption = Array.from(input.options).find(option => option.value === selectValue);
                    if (matchingOption) {
                      input.value = selectValue;
                    }
                  }
                } else {
                    input.value = settings[input.id]; // Load string for text, date, and textarea
                }
            }
        });
        // Restore nonWorkingConfig if present
        if (settings.nonWorkingConfig) {
          setNonWorkingDatesConfig(settings.nonWorkingConfig);
        }
        // Restore TasksSettings object if present
        if (settings.tasksSettings) {
          // Set tasks settings
          const tasksSettings = settings.tasksSettings;
          for (const taskId in tasksSettings) {
            TasksSettings.setTaskSettings(taskId, tasksSettings[taskId]);
          }
          // Set options in tasks selector
          const taskIdSelector = document.getElementById("taskIdSelector");
          const selectedTaskIds = settings.taskIdSelector;
          Array.from(taskIdSelector.options).forEach(option => {
            option.selected = selectedTaskIds.includes(option.value);
          });
          // Call generateGanttChart() after loading all settings
          generateGanttChart(eventButton);
        } else { //this is for old versions of JSON files not containing taksSettings
          // Remove task selector control
          const taskIdSelector = document.getElementById("taskIdSelector");
          const labelForTaskIdSelector = document.getElementById("labelForTaskIdSelector");
          taskIdSelector.remove();
          labelForTaskIdSelector.remove();
          // Call generateGanttChart() after tasks selector reset
          generateGanttChart(); 
        }
      } catch (error) {
          console.error("Failed to load settings:", error);
          alertWithConfirmation("Failed to load project. Please ensure the file is valid.");
      }
    });
    // Trigger the file input dialog
    fileInput.click();
  }

  // START === EDIT MODE FEATURE ===
  /**
   * Render editable task list on the left side when in edit mode
   * This replaces the static task name labels.
  */
  function renderEditableTaskList(tasks) {
    const svg = document.getElementById("ganttChart");
    if (!svg) return;
    // Find all task text elements in the SVG (these show names)
    const textElements = svg.querySelectorAll(".task-label");
    if (!textElements.length) return;
    textElements.forEach(textEl => {
      const taskId = parseInt(textEl.getAttribute("data-task-id"));
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;
      // Replace text with foreignObject containing form inputs
      const foreign = document.createElementNS(svgNS, "foreignObject");
      foreign.setAttribute("x", textEl.getAttribute("x"));
      foreign.setAttribute("y", textEl.getAttribute("y") - 12);
      foreign.setAttribute("width", 450);
      foreign.setAttribute("height", 30);

      const div = document.createElement("div");
      div.style.display = "flex";
      div.style.gap = "10px";
      div.style.alignItems = "center";
      div.style.fontSize = "10px";
      div.style.padding = "1px";
      div.style.border = "1px solid #ccc";

      const fields = [
        { name: "id", type: "number", value: task.id, width: "30px" },
        { name: "name", type: "text", value: task.name, width: "200px" },
        { name: "duration", type: "number", value: task.duration, width: "40px" },
        { name: "percentComplete", type: "number", value: task.percentComplete, width: "40px" },
        {
          name: "predecessors",
          type: "text",
          value: task.predecessors.map(
            p => `${p.id}${p.dependencyType}${p.leadLag ? (p.leadLag > 0 ? "+" : "") + p.leadLag + "d" : ""}`
          ).join(";"),
          width: "70px"
        },
        { name: "parentId", type: "number", value: task.parentId, width: "40px" }
      ];

      fields.forEach(f => {
        const input = document.createElement("input");
        input.type = f.type;
        if (f.type === "checkbox") input.checked = f.checked;
        else input.value = f.value;
        if (f.readonly) input.readOnly = true;
        input.style.width = f.width;
        input.style.fontSize = div.style.fontSize;

        input.addEventListener("change", () => applyTaskEdit(task.id, div));
        div.appendChild(input);
      });
      foreign.appendChild(div);
      // Replace text element with editable form
      textEl.replaceWith(foreign);
    });
  }

  /**
   * When an input field changes, update the CSV and refresh the Gantt chart
  */
  function applyTaskEdit(taskId, container) {
    const inputs = container.querySelectorAll("input");
    const updatedValues = Array.from(inputs).map(i =>
      i.type === "checkbox" ? i.checked : i.value
    );

    // Detect separator from first non-empty line
    const csvText = document.getElementById("csvInput").value.trim();
    const csvLines = csvText.split("\n");
    const firstLine = csvLines.find(line => line.trim().length > 0) || "";
    const separator = firstLine.includes("\t") ? "\t" : ",";

    // Update CSV lines
    const percentCompleteMultiplier = document.getElementById("percentCompleteMultiplier").checked;
    const updatedCSV = csvLines.map(line => {
      const parts = line.split(separator);
      if (parseInt(parts[0], 10) === taskId) {
        const baseValues = [
          updatedValues[0], // id
          updatedValues[1], // name
          updatedValues[2], // duration
          percentCompleteMultiplier ? updatedValues[3] / 100 : updatedValues[3], // percentComplete
          updatedValues[4]  // predecessors
        ];
        // Detect if the original CSV has a 'parent' column
        const hasParentColumn = isBooleanLike(parts[5]);
        const hasParentIdColumn = isNumericLike(parts[6]);
        if (hasParentColumn && hasParentIdColumn) {
          // Case 1: Old CSV â†’ has both parent + parentId
          baseValues.push(
            parts[5],  // parent
            updatedValues[5]   // parentId
          );
          console.log("vero, vero");
        } else if (hasParentColumn && !hasParentIdColumn) {
          // Case 2: Only parent column exists â†’ add new parentId column
          baseValues.push(
            parts[5],  // parent
            updatedValues[5]   // parentId (newly added)
          );
          console.log("vero, falso");
        } else {
          // Case 3: No parent column â†’ only parentId
          baseValues.push(updatedValues[5]);
          console.log("falso, falso");
        }
        return baseValues.join(separator);
      }
      return line;
    })
    .join("\n");

    document.getElementById("csvInput").value = updatedCSV;
    // Regenerate chart and keep edit mode active
    generateGanttChart();
    updateEditModeUI();
  }

  /**
   * Called after chart rendering to inject editable inputs if edit mode is active
  */
  function updateEditModeUI() {
    const csvInput = document.getElementById("csvInput").value;
    const tasks = parseCSV(
      csvInput,
      document.getElementById("percentCompleteMultiplier").checked,
      document.getElementById("projectStartDate").value,
      document.getElementById("todayDate").value
    );
    renderEditableTaskList(tasks);
  }

  // END === EDIT MODE FEATURE ===

  function generateGanttChart(event = null) {

    nextAlertConfirmed = true;

    const csvData = document.getElementById("csvInput").value;
    const leftMargin = parseInt(document.getElementById("leftMargin").value);
    const verticalShift = parseInt(document.getElementById("verticalShift").value);
    const offsetZeroX = parseInt(document.getElementById("offsetZeroX").value);
    const chartWidth = parseInt(document.getElementById("chartWidth").value);
    const rightMargin = parseInt(document.getElementById("rightMargin").value);
    const barHeight = parseInt(document.getElementById("barHeight").value);
    const barSpace = parseInt(document.getElementById("barSpace").value);
    const percentCompleteColor = document.getElementById("percentCompleteColor").value;
    const percentNotCompleteColor = document.getElementById("percentNotCompleteColor").value;
    const strokeColor = document.getElementById("strokeColor").value;
    const barBorderThickness = document.getElementById("barBorderThickness").value;
    const barAngles = document.getElementById("barAngles").value;

    const axesColor = document.getElementById("axesColor").value;
    const axesWidth = parseInt(document.getElementById("axesWidth").value);
    const verticalLinesWidth = parseInt(document.getElementById("verticalLinesWidth").value);
    const verticalLinesColor = document.getElementById("verticalLinesColor").value;
    const horizontalSeparatorsWidth = parseInt(document.getElementById("horizontalSeparatorsWidth").value);
    const horizontalSeparatorsColor = document.getElementById("horizontalSeparatorsColor").value;
    const todayDateLineColor = document.getElementById("todayDateLineColor").value;
    const todayDateLineWidth = parseInt(document.getElementById("todayDateLineWidth").value);
    const todayDateLineDashed = document.getElementById("todayDateLineDashed").value;
    
    const tasksCharSize = parseInt(document.getElementById("tasksCharSize").value);
    const tasksCharFamily = document.getElementById("tasksCharFamily").value;
    const tasksCharStyle = document.getElementById("tasksCharStyle").value;
    const tasksCharWeight = document.getElementById("tasksCharWeight").value;
    const tasksCharColor = document.getElementById("tasksCharColor").value;
    const tasksTruncate = parseInt(document.getElementById("tasksTruncate").value);
    const tasksDetailedInfo_0 = (document.getElementById("tasksDetailedInfo_0")).checked;
    const tasksDetailedInfo_1 = (document.getElementById("tasksDetailedInfo_1")).checked;
    const tasksDetailedInfo_2 = (document.getElementById("tasksDetailedInfo_2")).checked;    

    const parentPercentNotCompleteColor = document.getElementById("parentPercentNotCompleteColor").value;
    const parentPercentCompleteColor = document.getElementById("parentPercentCompleteColor").value;
    const parentBarAngles = document.getElementById("parentBarAngles").value;
    const parentsCharSize = parseInt(document.getElementById("parentsCharSize").value);
    const parentsCharFamily = document.getElementById("parentsCharFamily").value;
    const parentsCharStyle = document.getElementById("parentsCharStyle").value;
    const parentsCharWeight = document.getElementById("parentsCharWeight").value;
    const parentsCharColor = document.getElementById("parentsCharColor").value;

    const delayCharSize = parseInt(document.getElementById("delayCharSize").value);
    const delayCharFamily = document.getElementById("delayCharFamily").value;
    const delayCharStyle = document.getElementById("delayCharStyle").value;
    const delayCharColor = document.getElementById("delayCharColor").value;
    
    const datesCharSize = parseInt(document.getElementById("datesCharSize").value);
    const datesCharFamily = document.getElementById("datesCharFamily").value;
    const datesFormat = document.getElementById("datesFormat").value;
    const datesCharStyle = document.getElementById("datesCharStyle").value;
    const datesCharWeight = document.getElementById("datesCharWeight").value;
    const datesCharColor = document.getElementById("datesCharColor").value;
    
    const dependenciesLineColor = document.getElementById("dependenciesLineColor").value;
    const dependenciesLineWidth = document.getElementById("dependenciesLineWidth").value;
    const dependenciesLineDashed = document.getElementById("dependenciesLineDashed").value;
    const criticalPathLineColor = document.getElementById("criticalPathLineColor").value;
    const criticalPathLineWidth = document.getElementById("criticalPathLineWidth").value;
    const timelineY = parseInt(document.getElementById("timelineY").value);
    const offsetTextTaskH = parseInt(document.getElementById("offsetTextTaskH").value);
    const offsetDateBarV = parseInt(document.getElementById("offsetDateBarV").value);
    const offsetDateBarLeftH = parseInt(document.getElementById("offsetDateBarLeftH").value);
    const offsetDateBarRightH = parseInt(document.getElementById("offsetDateBarRightH").value);
    const headerDatesCharSize = parseInt(document.getElementById("headerDatesCharSize").value);
    const headerDatesCharFamily = document.getElementById("headerDatesCharFamily").value;
    const headerDatesFormat = document.getElementById("headerDatesFormat").value;
    const headerDatesCharStyle = document.getElementById("headerDatesCharStyle").value;
    const headerDatesCharWeight = document.getElementById("headerDatesCharWeight").value;
    const headerDatesCharColor = document.getElementById("headerDatesCharColor").value;
    const headerSpaceFromTimelineY = parseInt(document.getElementById("headerSpaceFromTimelineY").value);
    const headerDatesSpace = parseInt(document.getElementById("headerDatesSpace").value);

    const percentCompleteMultiplier = (document.getElementById("percentCompleteMultiplier")).checked;
    const projectStartDate = (document.getElementById("projectStartDate")).value;
    const todayDate = (document.getElementById("todayDate")).value;
    
    const showOnlyNotParents = (document.getElementById("showOnlyNotParents")).checked;
    const showOnlyParents = (document.getElementById("showOnlyParents")).checked;
    const showOnlyNotDelay = (document.getElementById("showOnlyNotDelay")).checked;
    const showOnlyDelay = (document.getElementById("showOnlyDelay")).checked;
    const showOnlyNotCritical = (document.getElementById("showOnlyNotCritical")).checked;
    const showOnlyCritical = (document.getElementById("showOnlyCritical")).checked;
    const showOnlyNotMilestone = (document.getElementById("showOnlyNotMilestone")).checked;
    const showOnlyMilestone = (document.getElementById("showOnlyMilestone")).checked;
    const showOnlyNotSelected = (document.getElementById("showOnlyNotSelected")).checked;
    const showOnlySelected = (document.getElementById("showOnlySelected")).checked;

    const editMode = document.getElementById("editMode") ? (document.getElementById("editMode")).checked : false;

    let tasks = null;
    if (!event ||
        event.target.id == "csvInput" || 
        event.target.id == "nonWorkingDates" ||
        event.target.id == "projectStartDate" ||
        event.target.id == "todayDate" ||
        event.target.id == "percentCompleteMultiplier" ||
        event.target.id == "openProjectFromFile") {
      tasks = parseCSV(csvData, percentCompleteMultiplier, projectStartDate, todayDate);
      tasksCache = tasks;
    } else 
      tasks = tasksCache;
    const { minDate, maxDate, uniqueStartDates } = calculateTimeline(tasks);

    // Create the Selector Control only once to avoid re-creation at each event on the page
    if (!document.getElementById("taskIdSelector")) createTasksSelectorControl(tasks);
    // Update Options in Selector Control only when input CSV changes
    if (event && event.target.id == "csvInput") updateOptionsInTasksSelectorControl(tasks);

    createGanttChart(tasks, minDate, maxDate, new Date(todayDate), uniqueStartDates, event, {
      leftMargin,
      verticalShift,
      offsetZeroX,
      chartWidth,
      rightMargin,
      barHeight,
      barSpace,
      percentCompleteColor,
      percentNotCompleteColor,
      strokeColor,
      barBorderThickness,
      barAngles,
      axesColor,
      axesWidth,
      verticalLinesWidth,
      verticalLinesColor,
      horizontalSeparatorsWidth,
      horizontalSeparatorsColor,
      tasksCharSize,
      tasksCharFamily,
      tasksCharStyle,
      tasksCharWeight,
      tasksCharColor,
      tasksTruncate,
      tasksDetailedInfo_0,
      tasksDetailedInfo_1,
      tasksDetailedInfo_2,
      parentPercentNotCompleteColor,
      parentPercentCompleteColor,
      parentBarAngles,
      parentsCharSize,
      parentsCharFamily,
      parentsCharStyle,
      parentsCharWeight,
      parentsCharColor,
      delayCharSize,
      delayCharFamily,
      delayCharStyle,
      delayCharColor,
      datesCharSize,
      datesCharFamily,
      datesFormat,
      datesCharStyle,
      datesCharWeight,
      datesCharColor,
      dependenciesLineColor,
      dependenciesLineWidth,
      dependenciesLineDashed,
      criticalPathLineColor,
      criticalPathLineWidth,
      timelineY,
      offsetTextTaskH,
      offsetDateBarV,
      offsetDateBarLeftH,
      offsetDateBarRightH,
      headerDatesCharSize,
      headerDatesCharFamily,
      headerDatesFormat,
      headerDatesCharStyle,
      headerDatesCharWeight,
      headerDatesCharColor,
      headerSpaceFromTimelineY,
      headerDatesSpace,
      todayDateLineColor,
      todayDateLineWidth,
      todayDateLineDashed, 
      showOnlyNotParents, showOnlyParents, 
      showOnlyNotDelay, showOnlyDelay, 
      showOnlyCritical, showOnlyNotCritical,
      showOnlyNotMilestone, showOnlyMilestone,
      showOnlyNotSelected, showOnlySelected,
      editMode
    });

    if (editMode) updateEditModeUI();

  }
</script>

</body>
</html>
